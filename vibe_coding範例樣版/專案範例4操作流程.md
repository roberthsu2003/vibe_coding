# 專案範例4操作流程

實際範例展示AI如何協助Code Review和Refactoring

## 系統預先需求

- git
- conda

## 檢查預先需求

### 使用terminal inline chat

1. ❗️檢查是否安裝git

> 
```
系統是否有安裝git
```

> 如果沒有安裝,請安裝git

2. ❗️git是否初始化

- 注意:老師的不要初始化(老師的上層目錄已經初始化),學員的要初始化(學員的是新專案)

> 
```
我這個目錄是否有git管理
```

> 如果沒有,請初始化git。
> `git init`

3. ❗️是否有安裝conda

>
```
系統是否安裝conda
```

> 如果沒有,請安裝conda
> 注意:conda安裝完,必需執行`conda init`

4. ❗️檢查conda是否有安裝`vibe_coding`虛擬環境

> 
```
conda 是否已經建立"vibe_coding"虛擬環境?
```

> 如果沒有請建立”vibe_coding”虛擬環境,也可嘗試請ai建立
> `conda create -n vibe_coding python=3.11`

5. 終端機進入虛擬環境

`conda activate vibe_coding`

### code review開始

#### 一般性的問題(1main.py)

```python
def add_numbers(a, b):
    return a - b
    
問題:
function的名稱和實作不一致
```

```python
def find_max(numbers):
    max_number = numbers[0]
    for number in numbers:
        if number < max_number:
            max_number = number
    return max_number
    
問題:
邏輯錯誤
```

```python
def calculate_average(numbers):
    total = 0
    for number in numbers:
        total += number
    return total / len(number)
    
問題:
有濳在的問題,除數可能為0
```

```python

def main():
    add_numbers(1, 3)

問題:
沒有作用的程式碼
```

**解法方法**:

```
#使用copilot chat view,ask mode
#只會說明不會修改程式碼
#試著更改模型,會有不一樣的結果

請解釋程式碼
```

#### 難以閱讀和維護的問題(2nestedLogic.py)

```
def determine_access_nested(user_role, has_permission, is_active):
    """原始版本：深度巢狀結構，難以閱讀和維護"""
    if user_role == "admin":
        if has_permission:
            if is_active:
                return "Active admin account with full access."
            else:
                return "Inactive admin account."
        else:
            return "Admin account lacks necessary permissions."
    else:
        return "Access denied"

問題:深度巢狀判斷
```

**解法方法**

```
#先使用ask mode,再使用edit或agent模式
#先選取function(支援選取的程式碼)
這段程式碼可以有更簡捷和更有效率的寫法嗎?
```

#### 效能不好的問題(3performance.py)

```
# 問題1: 重複計算相同的值
def calculate_factorial_slow(n):
    """計算階乘，但每次都重新計算"""
    def factorial(x):
        if x <= 1:
            return 1
        return x * factorial(x - 1)
    
    result = []
    for i in range(n):
        # 每次都重新計算 factorial(10)
        result.append(factorial(10) + i)
    return result
```

```
# 問題2: 在迴圈中使用低效的字串連接
def build_string_slow(words):
    """使用 + 來連接字串，效率低下"""
    result = ""
    for word in words:
        result = result + word + " "
    return result
```

```
# 問題3: 使用不當的資料結構
def find_duplicates_slow(numbers):
    """使用列表來查找重複，時間複雜度 O(n²)"""
    duplicates = []
    for i in range(len(numbers)):
        for j in range(i + 1, len(numbers)):
            if numbers[i] == numbers[j] and numbers[i] not in duplicates:
                duplicates.append(numbers[i])
    return duplicates
```

```
# 問題4: 不必要的深拷貝
def process_data_slow(data):
    """每次處理都創建新的副本"""
    import copy
    results = []
    for item in data:
        # 不必要的深拷貝
        temp = copy.deepcopy(item)
        temp['processed'] = True
        results.append(temp)
    return results
```

```
# 問題5: 低效的排序
def sort_students_slow(students):
    """使用冒泡排序，時間複雜度 O(n²)"""
    n = len(students)
    for i in range(n):
        for j in range(0, n - i - 1):
            if students[j]['score'] < students[j + 1]['score']:
                students[j], students[j + 1] = students[j + 1], students[j]
    return students
```

```
# 問題6: 記憶體洩漏風險
class DataProcessor:
    def __init__(self):
        self.cache = {}
        self.processed_items = []
    
    def process_item(self, item):
        """快取不斷增長，沒有清理機制"""
        if item['id'] not in self.cache:
            # 模擬複雜計算
            time.sleep(0.001)
            self.cache[item['id']] = item['value'] * 2
        
        # 保存所有處理過的項目（記憶體洩漏）
        self.processed_items.append(item)
        return self.cache[item['id']]
```

#### 命名不佳的問題(4readability.py)

```
#不好的命名
def log_persons_age(a, b, c):
    if c:
        print(f"{a} is {b} years old.")
    else:
        print(f"{a} does not want to reveal their age.")
```

**解決方法**

```
#使用edit或agent模式
優化程式碼的效能
```

```
- 改善這段程式碼的可讀性
- 改善函式參數的命名
```

#### 不安全的問題(5script.py)

```
#安全性的問題(SQL注入的問題)
#!/bin/python3

import pymysql

def run(name):
    db = pymysql.connect(
        host="localhost",
        root="root",
        password="password",
        database="my_db")
    cursor = db.cursor()
    cursor.execute("SELECT * FROM users WHERE name = '%s'" % name)
    db.close()
```

**解決方法**



```
請檢查程式碼安全性問題
```



## 如何實際操作Code review

1. 在程式碼內,按右鍵,選取copilot內的`檢閱並認可`(就是code review),這是針對整個檔案

2. 在chat view內,附加該檔案,並詢問

```prompt
code review
```

## 如何實際操作Code refactoring

1. 在chat view內,附加該檔案,並詢問

```prompt
code refactoring
```

