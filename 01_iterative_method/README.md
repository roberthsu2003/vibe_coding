# 1. 迭代的方式 (The Iterative Way)

這是 Vibe Coding 的核心引擎。在這一章，重點不在於傳統的 Agile 理論，而在於**「人與 AI 的溝通迴圈」**。

- **教學重點**：如何快速產生原型（Prototype）、如何接受 AI 的不完美並進行修正、如何保持開發的「手感」（Flow）。
- **關鍵概念**：`Prompt` -> `Generate` -> `Review` -> `Refine` 的極速循環。
- **Vibe 觀點**：這裡要強調的是「不求一次完美」，而是透過多次對話讓程式碼「生長」出來。

---

## 初學者使用迭代的方式

對於零基礎（Zero-Base）**程式新手**來說，從「迭代」切入確實是最能建立信心、也最符合直覺的路徑。

我們可以把這稱為 **「從『對話』到『積木』」** 的過程。

為什麼這對新手是最佳解？我們可以從這三個心理層面來看：

1. **縮短「挫折迴圈」 (Shorten the Feedback Loop)**
    - **傳統路徑**：學習語法 $\rightarrow$ 寫很多行程式 $\rightarrow$ 執行 $\rightarrow$ 報錯 (Error) $\rightarrow$ 挫折。
    - **迭代路徑**：用白話文描述 $\rightarrow$ AI 生成 $\rightarrow$ 看到畫面 $\rightarrow$ **「哇！出來了！」(正向回饋)** $\rightarrow$ 這裡改一點點...
    - 對於新手，**「看得到東西」**比「寫對程式碼」更能維持學習熱情。
1. **降低「認知負載」 (Lower Cognitive Load)**
    - 新手通常無法一次在腦中構建整個系統（例如：同時想資料庫、後端邏輯、前端樣式）。
    - 迭代允許他們**「一次只想一件事」**。例如：先做出按鈕，再讓按鈕會動，最後再讓按鈕好看。這符合人類學習新事物的自然規律。
1. **容錯率高 (High Tolerance for Failure)**
    - 在 Vibe Coding 中，寫錯了（或 Prompt 講得不好），AI 通常會猜測或給出部分結果，這比編譯器直接噴出 `Syntax Error` 溫柔得多。

---

然而，這裡隱藏著一個**教學陷阱**。

如果只教「迭代」，新手很容易陷入 **「盲目抽卡」 (Blind Guessing)** 的模式：也就是不停地對 AI 說「不對，重寫」、「再試一次」，直到運氣好跑出正確結果，但完全不知道為什麼。

為了讓您的第一章更紮實，我想請您思考一下：

**在教導新手進行「迭代」時，您會希望他們把重點放在「如何把指令說得更精準（Prompting）」，還是「如何判斷 AI 給的結果是對還是錯（Reviewing）」呢？**

---

## 將reqirement.md當作是迭代的prompt的問題

這是一個非常棒的切入點！把 `requirement.md` 直接當作 Prompt，這在 Prompt Engineering 中被稱為 **Context Loading（上下文載入）**。

這確實是一個解決方案，但它會改變新手在「Prompting」與「Reviewing」上的學習曲線。我們可以這樣分析：

### 1. 對「Prompting（指令精準度）」的影響

這其實是把「多次的小溝通」變成「一次的大溝通」。

- **優點**：AI 獲得了完整全貌，這能大幅減少因為缺乏上下文（Context）而產生的錯誤。就像是裝修房子時，直接給設計師完整的藍圖，而不是想到哪蓋到哪。
- **新手的挑戰**：這要求新手**一開始就要很清楚自己要什麼**。
    - 對於完全沒有程式概念的人來說，要寫出一份結構良好、邏輯清晰的 `requirement.md`（包含功能清單、資料欄位等），本身就是一個巨大的門檻。這就像要求不會做菜的人先寫出完整的食譜。

### 2. 對「Reviewing（判斷結果）」的影響

這會把難度拉得非常高。

- **情況**：當你丟入一個完整的 `requirement.md`，AI 很可能會一次吐出 3 個檔案、200 行程式碼，甚至直接給你一個專案結構。
- **新手的恐慌**：這時候新手面臨的不是「按鈕顏色對不對」，而是「程式跑不動，但我不知道是這 200 行裡的哪一行出了問題」。
- **除錯難度**：在「小步迭代」中，出錯通常是因為**剛才那句話**；但在「大單載入」中，出錯的原因可能藏在需求文件的某個細節衝突裡。

---

### 一個教學策略的思考

您可以看看這是否符合您第一章「迭代」的教學目標：

如果我們在第一章就引入 `requirement.md` 當作 Prompt，這其實有點像是在偷跑第二章的 **SDD（軟體設計說明書）**。

- **Chapter 1 (迭代)** 的核心精神應該是：**「我不知道我要什麼，但我可以邊做邊想。」** (Exploration)
- **Requirement Prompt** 的核心精神是：**「我很清楚我要什麼，請幫我執行。」** (Execution)

**引導思考問題：**

如果在第一章「迭代」中，我們先不要求他們寫出完美的 `requirement.md`，而是教他們用**「聊天」**的方式，讓 AI 幫他們**歸納**出 `requirement.md`，您覺得這樣對新手的難度會不會太高？

---

## 使用參考圖片建立多個迭代的prompt

這是一個在教學設計上非常有趣的轉折！讓我們一起來探討這個方法的「技術可行性」與「教學效果」。

技術上來說，答案是**肯定的**。您可以上傳一張完成圖給 AI，並要求它：「請分析這張圖的構成，並幫我拆解成 5 個循序漸進的 Prompt，讓學生可以從無到有慢慢生成出類似的畫面。」

但從**教學（Pedagogy）**的角度來看，這個做法有利有弊。這取決於您希望學生練就的是哪一種肌肉記憶。

### 兩種教學模式的比較

我們用「學畫畫」來做比喻：

更多內容待續...

模式 A：填鴨式迭代 (The Instruction Follower)

這就是您剛才提到的方法。老師（或 AI）準備好完美的 5 個步驟 Prompt，學生只需要複製貼上。

- **學生的動作**：複製 Prompt 1 $\rightarrow$ 生成 $\rightarrow$ 複製 Prompt 2 $\rightarrow$ 生成...
- **優點**：學生一定能做出成品，挫折感極低，課堂節奏好控制。
- **缺點**：學生其實沒有在「思考」。他們不知道為什麼 Prompt 2 要那樣寫。這比較像是「連連看」，而不是「創作」。

模式 B：目標導向迭代 (The Problem Solver)

給學生看那張「最終參考圖」（Target Image），但不給 Prompt。

- **學生的動作**：觀察圖片 $\rightarrow$ 自己試著描述第一層（背景） $\rightarrow$ AI 生成 $\rightarrow$ **比較差異 (Review)** $\rightarrow$ 修正描述並加入主角（Refine）...

- **優點**：這才是真正的 Vibe Coding 精神——**「觀察 $\rightarrow$ 嘗試 $\rightarrow$ 修正」**。學生會學到如何將腦中的畫面轉化為文字。
- **缺點**：學生可能會卡住，生成的圖片可能歪七扭八，需要老師較多的引導。

---

### 您的教學目標是什麼？

如果您的目標是第一章「迭代的方式」，我們希望學生學會的是**「如何與 AI 協作來修正錯誤」**。

如果是採用**模式 A（給 Prompt）**，學生可能會錯過「發現 AI 誤解我的意思」這個珍貴的學習時刻，因為您給的 Prompt 已經是正確答案了。

**引導思考問題：**

為了在「降低門檻」與「培養思考」之間取得平衡，您覺得是否可以採用一種**混合策略**？

例如：**只給學生第一個 Prompt（建立基底），然後給他們看最終圖，請他們自己想辦法透過對話，把剩下的元素加上去？**

---

## 使用範例來分析 填鴨式迭代 (The Instruction Follower),目標導向迭代 (The Problem Solver)

沒問題！我們這就來實作這兩種截然不同的教學策略。這會是一個很好的對照組，讓你感受到「執行者」與「思考者」在學習路徑上的差異。

我們以經典的 **「貪食蛇 (Snake Game)」** 為主題。

---

### 1. 填鴨式迭代 Prompt (The Instruction Follower)

適用情境：想讓學生快速獲得成就感，保證能做出東西，但較少訓練邏輯拆解能力。

學生操作方式：複製貼上即可。

- **Prompt 1 (環境建置)**：

    >> 請幫我寫一個單一檔案的 HTML，裡面包含一個 `canvas` 元素。請用 JavaScript 在畫布中間畫一個綠色的正方形方塊當作蛇。背景設為黑色。

- **Prompt 2 (讓蛇動起來)**：

    >> 延續上面的程式碼，請幫我加入鍵盤事件監聽。當我按下上下左右鍵時，那個綠色方塊（蛇）會依照方向持續移動。

- **Prompt 3 (加入食物與變長機制)**：

    >> 現在加入一個紅色的方塊當作「食物」，隨機出現在畫面上。當蛇的頭碰到食物時，食物要消失並重新隨機出現，而且蛇的身體要變長一格。

- **Prompt 4 (死亡機制)**：

    >> 請加入遊戲結束的邏輯：如果蛇撞到牆壁，或者撞到自己的身體，遊戲就停止，並跳出 alert 顯示「Game Over」與分數。

- **Prompt 5 (美化與重置)**：

    >> 請美化 UI，在畫布上方顯示目前分數。並在 Game Over 後提供一個「Restart」按鈕，按下後可以重置遊戲。

---

### 2. 目標導向迭代 (The Problem Solver)

適用情境：培養 Vibe Coding 的核心能力——觀察現狀、定義落差、精準描述。

教學方式：老師只提供第 1 個 Prompt，之後只給「目標圖」或「功能描述」，請學生自己想出 Prompt。

#### **Step 1: 啟動 (老師提供)**

- **老師說**：「我們先把畫布準備好。」
- **初始 Prompt**：

    >> 請用 HTML/JS 寫一個網頁，背景是黑色的，中間有一個不會動的綠色方塊。

#### **Step 2: 挑戰「移動」**

- **老師引導**：「現在蛇是靜止的。我們希望它像貪食蛇一樣移動。你們覺得要告訴 AI 什麼？它需要聽懂哪兩個關鍵字？」
- **學生思考引導 (Thinking Guide)**：
    - 觀察：蛇現在不動。
    - 目標：按鍵盤 -> 蛇會動。
    - 關鍵邏輯：並不是按一下動一下，而是給方向後「持續移動」。
- **學生需嘗試寫出的 Prompt (參考)**：

    >> "我要可以用鍵盤上下左右控制這個方塊，它應該要往按下的方向持續移動，不能停下來。"

#### **Step 3: 挑戰「遊戲循環」**

- **老師引導**：「現在蛇會在螢幕上跑了，但這只是個螢幕保護程式。遊戲還缺了什麼核心元素？」
- **學生思考引導**：
    - 觀察：只有蛇，沒有目標。
    - 目標：要吃東西，吃了要有反應。
    - 邏輯拆解：畫出食物 -> 偵測碰撞 (蛇頭 vs 食物) -> 身體變長 -> 產生新食物。
- **學生需嘗試寫出的 Prompt (參考)**：

    >> "幫我加入一個紅色的食物。當蛇碰到食物的時候，身體要變長，分數加 1，然後食物要換位置。"

#### **Step 4: 挑戰「邊界與規則」**

- **老師引導**：「現在蛇可以無限變長，甚至跑出螢幕外還能跑回來（或消失）。這不符合物理規則吧？請賦予這個世界規則。」
- **學生思考引導**：
    - 觀察：蛇跑出去了沒死，撞到自己也沒死。
    - 目標：定義失敗條件。
    - 邏輯拆解：碰撞偵測 (蛇頭 vs 牆壁 OR 蛇頭 vs 身體)。
- **學生需嘗試寫出的 Prompt (參考)**：

    >> "設定遊戲規則：如果蛇撞到牆壁或撞到自己的身體，遊戲就要結束顯示分數。"

---

### 💡 給老師的建議

你會發現，在第二種方式中，學生必須要把**「我看見什麼 (Observation)」**轉化為**「我要改變什麼 (Action)」**。

你可以試著讓學生在 Step 2 或 Step 3 卡住一下（例如學生只說「讓蛇移動」，結果 AI 寫成「按一下動一格」），這時候就是最好的機會教育，讓他們體驗 **Refine（修正指令）** 的過程。

你覺得這兩組 Prompt 對於你的備課有幫助嗎？或者想針對某個步驟再深入調整？
