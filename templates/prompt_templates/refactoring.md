# Refactoring Prompts

> AI 輔助程式碼重構的 Prompt 範本集

---

## 基礎重構

### Prompt 1: 提升可讀性

```
請重構以下程式碼,提升可讀性:

重構目標:
1. 改善變數和函式命名
2. 簡化複雜的邏輯
3. 移除不必要的程式碼
4. 加入適當的註解 (僅在必要處)

要求:
- 保持功能不變
- 不改變對外介面 (public API)
- 說明每個重構的理由

[貼上程式碼]
```

---

### Prompt 2: 消除重複程式碼 (DRY)

```
以下程式碼有很多重複的部分,請幫我重構:

目標:
1. 找出所有重複的程式碼
2. 提取成共用函式或模組
3. 確保重構後更容易維護

請提供:
- 重複程式碼的位置
- 如何提取共用邏輯
- 重構後的完整程式碼

[貼上程式碼]
```

---

### Prompt 3: 函式拆分

```
這個函式太長/太複雜,請幫我拆分:

當前問題:
- 函式行數: [X] 行
- 職責: [做太多事情]

重構要求:
1. 每個函式只做一件事 (Single Responsibility)
2. 函式長度不超過 30 行
3. 命名清楚表達用途
4. 保持原有功能

[貼上長函式]

請提供:
- 拆分後的函式
- 每個函式的職責說明
- 函式間的呼叫關係圖
```

---

## 設計模式應用

### Prompt 4: 套用設計模式

```
請分析以下程式碼,並建議適合的設計模式:

目前的問題:
- [例如: 有很多 if-else 判斷不同類型]
- [例如: 需要動態新增功能]

請建議:
1. 哪種設計模式適合?
2. 為什麼適合?
3. 如何重構來套用這個模式?
4. 重構後的程式碼範例

[貼上程式碼]
```

---

### Prompt 5: Strategy Pattern (策略模式)

```
請使用策略模式重構以下程式碼:

當前問題:
- 有很多條件判斷 (if-else 或 switch-case)
- 每種條件對應不同的處理邏輯

重構目標:
1. 將每種策略提取成獨立的類別/函式
2. 使用依賴注入選擇策略
3. 讓新增策略更容易

[貼上程式碼]

請提供:
- 策略介面定義
- 每個具體策略的實作
- 使用範例
```

---

## 效能優化重構

### Prompt 6: 優化效能

```
請重構以下程式碼以提升效能:

目前的效能問題:
- [例如: 有 N+1 查詢問題]
- [例如: 迴圈中有重複計算]

優化目標:
1. 降低時間複雜度
2. 減少不必要的計算
3. 改善資料庫查詢效率

請提供:
- 當前的複雜度分析
- 優化後的複雜度
- 詳細的優化說明
- 重構後的程式碼

[貼上程式碼]
```

---

### Prompt 7: 快取機制

```
請為以下程式碼加入適當的快取機制:

快取需求:
- [描述什麼需要快取]
- [快取失效策略]
- [快取時間]

請建議:
1. 在哪裡加入快取?
2. 使用什麼快取策略?
3. 如何處理快取失效?
4. 實作範例

[貼上程式碼]
```

---

## 架構重構

### Prompt 8: 分層架構

```
請將以下程式碼重構成分層架構:

目標架構:
- Controller Layer (處理請求)
- Service Layer (業務邏輯)
- Repository Layer (資料存取)

要求:
1. 清楚分離各層職責
2. 依賴方向正確 (Controller → Service → Repository)
3. 每層都可獨立測試

[貼上程式碼]

請提供:
- 重構後的檔案結構
- 每一層的程式碼
- 層與層之間的介面定義
```

---

### Prompt 9: 模組化重構

```
這個檔案太大了,請幫我拆分成多個模組:

當前問題:
- 檔案行數: [X] 行
- 包含多個不相關的功能

重構目標:
1. 按功能拆分成多個檔案
2. 每個檔案職責單一
3. 清楚的 import/export 關係

[貼上程式碼]

請提供:
- 建議的檔案結構
- 每個檔案的內容
- 模組之間的依賴關係
```

---

## 特定語言/框架重構

### Prompt 10: React Hooks 重構

```
請將這個 Class Component 重構成 Function Component with Hooks:

要求:
1. 使用 useState 取代 state
2. 使用 useEffect 取代生命週期方法
3. 保持原有功能不變
4. 使用適當的 hooks 最佳實踐

[貼上 Class Component]

請提供:
- 重構後的 Function Component
- 使用的 hooks 說明
- 注意事項
```

---

### Prompt 11: Async/Await 重構

```
請將以下 Promise chain 重構成 async/await:

要求:
1. 使用 async/await 語法
2. 適當的錯誤處理 (try-catch)
3. 保持原有的錯誤處理邏輯
4. 提升可讀性

[貼上 Promise chain 程式碼]
```

---

## 測試友善重構

### Prompt 12: 提升可測試性

```
請重構以下程式碼,讓它更容易測試:

目前的測試困難:
- [例如: 直接呼叫外部 API]
- [例如: 使用全域變數]
- [例如: 難以 mock 依賴]

重構目標:
1. 使用依賴注入
2. 避免全域狀態
3. 讓外部依賴可替換 (mockable)

[貼上程式碼]

請提供:
- 重構後的程式碼
- 如何進行測試的範例
```

---

### Prompt 13: 分離副作用

```
請分離以下程式碼的純函式邏輯與副作用:

目標:
1. 將純粹的計算邏輯提取出來
2. 隔離副作用 (I/O, API calls, 資料庫操作)
3. 純函式部分更容易測試

[貼上程式碼]

請提供:
- 純函式部分
- 副作用部分
- 如何組合兩者
```

---

## 錯誤處理重構

### Prompt 14: 改善錯誤處理

```
請改善以下程式碼的錯誤處理:

目前問題:
- 錯誤處理不一致
- 錯誤訊息不清楚
- 沒有適當的錯誤恢復機制

改善目標:
1. 統一的錯誤處理方式
2. 有意義的錯誤訊息
3. 適當的錯誤分類
4. 錯誤日誌記錄

[貼上程式碼]
```

---

## 安全性重構

### Prompt 15: 修復安全漏洞

```
以下程式碼有安全問題,請協助重構:

已知的安全問題:
- [例如: 可能有 SQL Injection]
- [例如: 密碼未加密]

重構要求:
1. 修復所有安全漏洞
2. 加入輸入驗證
3. 使用參數化查詢
4. 敏感資料加密

[貼上程式碼]

請提供:
- 具體的安全問題說明
- 重構後的安全程式碼
- 安全性檢查清單
```

---

## 型別安全重構

### Prompt 16: 加入 TypeScript

```
請將以下 JavaScript 程式碼重構成 TypeScript:

要求:
1. 為所有函式加入型別註解
2. 為物件定義 interface 或 type
3. 避免使用 any
4. 使用泛型提升型別安全

[貼上 JavaScript 程式碼]

請提供:
- TypeScript 版本的程式碼
- 型別定義檔 (.d.ts)
- 型別設計的說明
```

---

## 重構步驟指引

### Prompt 17: 分步重構計畫

```
這段程式碼需要大幅重構,但我擔心一次改太多會出錯。
請提供一個**漸進式重構計畫**:

要求:
1. 將重構分成多個小步驟
2. 每個步驟都可獨立驗證
3. 保持每一步都有可執行的程式碼
4. 說明每一步的測試方式

[貼上程式碼]

請提供:
- 完整的重構步驟清單
- 每一步的具體作法
- 每一步的驗證方式
- 預估每一步的時間
```

---

## 程式碼簡化

### Prompt 18: 簡化條件邏輯

```
以下程式碼有太多巢狀的 if-else,請簡化:

目標:
1. 減少巢狀層級 (最多 2-3 層)
2. 使用 early return
3. 提升可讀性

[貼上複雜的條件邏輯]

請提供:
- 簡化後的程式碼
- 簡化的技巧說明
```

---

### Prompt 19: 簡化迴圈

```
請簡化以下複雜的迴圈:

可能的簡化方向:
1. 使用高階函式 (map, filter, reduce)
2. 使用 ES6+ 語法
3. 提取迴圈內的複雜邏輯

[貼上複雜迴圈]
```

---

## 重構驗證

### Prompt 20: 產生重構測試

```
我要重構以下程式碼,請幫我先產生測試:

目標:
1. 確保重構後行為不變
2. 測試涵蓋所有重要情境
3. 可以作為重構的安全網

[貼上要重構的程式碼]

請提供:
- 完整的測試案例
- 測試程式碼
- 建議的重構步驟
```

---

## 使用技巧

### 重構的黃金法則

1. **小步前進**: 一次只重構一個小部分
2. **測試先行**: 重構前先有測試保護
3. **保持功能**: 重構不改變外部行為
4. **持續驗證**: 每一步都執行測試

### 何時該重構?

使用這個 Prompt 來判斷:

```
請分析以下程式碼,告訴我是否需要重構:

評估標準:
1. 程式碼複雜度 (圈複雜度)
2. 重複程式碼比例
3. 函式長度
4. 命名品質
5. 可測試性

如果需要重構,請說明:
- 優先級 (高/中/低)
- 建議的重構方向
- 預估的工作量

[貼上程式碼]
```

---

**提示**:
- 重構是持續的過程,不是一次性的任務
- 每次修 bug 或加功能時,都是重構的好時機
- 使用版本控制,確保可以隨時回復
- 重構前後都要執行完整的測試
