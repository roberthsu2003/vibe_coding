# gemini_命令說明
Gemini CLI 支援多種內建指令，協助您管理會話、自訂介面並控制其行為。這些指令以斜線 (/)、at 符號 (@) 或驚嘆號 (!) 作為前置符號。

## 斜線指令 (`/`)

斜線指令提供對 CLI 本身的元級別控制。

### 內建指令

- **`/bug`**
  - **說明：** 回報有關 Gemini CLI 的問題。預設情況下，問題會回報至 Gemini CLI 的 GitHub 儲存庫。您在 `/bug` 後輸入的字串將成為所回報錯誤的標題。可以使用 `.gemini/settings.json` 檔案中的 `bugCommand` 設定來修改預設的 `/bug` 行為。

- **`/chat`**
  - **說明：** 儲存和恢復對話歷史記錄，以便以互動方式分支對話狀態，或從之後的會話中恢復先前的狀態。
  - **子指令：**
    - **`save`**
      - **說明：** 儲存目前的對話歷史記錄。您必須新增一個 `<tag>` 來識別對話狀態。
      - **用法：** `/chat save <tag>`
      - **關於檢查點位置的詳細資訊：** 儲存的聊天檢查點的預設位置為：
        - Linux/macOS：`~/.gemini/tmp/<project_hash>/`
        - Windows：`C:\Users\<YourUsername>\.gemini\tmp\<project_hash>\`
        - 當您執行 `/chat list` 時，CLI 僅掃描這些特定目錄以尋找可用的檢查點。
        - **注意：** 這些檢查點用於手動儲存和恢復對話狀態。有關在修改檔案之前建立的自動檢查點，請參閱 [檢查點文件](../checkpointing.md)。
    - **`resume`**
      - **說明：** 從先前的儲存中恢復對話。
      - **用法：** `/chat resume <tag>`
    - **`list`**
      - **說明：** 列出可用於聊天狀態恢復的標籤。
    - **`delete`**
      - **說明：** 刪除已儲存的對話檢查點。
      - **用法：** `/chat delete <tag>`

- **`/clear`**
  - **說明：** 清除終端機螢幕，包括 CLI 中可見的會話歷史記錄和捲動緩衝區。底層的會話資料（用於歷史記錄回憶）可能會根據具體的實作而保留，但視覺顯示會被清除。
  - **鍵盤快速鍵：** 隨時按 **Ctrl+L** 執行清除操作。

- **`/compress`**
  - **說明：** 將整個聊天內容替換為摘要。這樣可以在保留已發生事件的高級摘要的同時，節省未來任務所使用的權杖。

- **`/copy`**
  - **說明：** 將 Gemini CLI 產生的最後一個輸出複製到剪貼簿，以便輕鬆分享或重複使用。
  - **注意：** 此指令需要安裝特定於平台的剪貼簿工具。
    - 在 Linux 上，它需要 `xclip` 或 `xsel`。您通常可以使用系統的套件管理器來安裝它們。
    - 在 macOS 上，它需要 `pbcopy`，在 Windows 上，它需要 `clip`。這些工具通常預先安裝在其各自的系統上。

- **`/directory`** (或 **`/dir`**)
  - **說明：** 管理用於多目錄支援的工作區目錄。
  - **子指令：**
    - **`add`**：
      - **說明：** 將目錄新增至工作區。路徑可以是絕對路徑或相對於目前工作目錄的路徑。此外，也支援從主目錄的引用。
      - **用法：** `/directory add <path1>,<path2>`
      - **注意：** 在限制性沙箱設定檔中已停用。如果您正在使用該設定檔，請在啟動會話時改用 `--include-directories`。
    - **`show`**：
      - **說明：** 顯示由 `/directory add` 和 `--include-directories` 新增的所有目錄。
      - **用法：** `/directory show`

- **`/editor`**
  - **說明：** 開啟一個用於選擇支援的編輯器的對話方塊。

- **`/extensions`**
  - **說明：** 列出目前 Gemini CLI 會話中的所有活動擴充功能。

- **`/help`** (或 **`/?`**)
  - **說明：** 顯示有關 Gemini CLI 的說明資訊，包括可用指令及其用法。

- **`/mcp`**
  - **說明：** 列出已設定的模型內容協定 (MCP) 伺服器、其連線狀態、伺服器詳細資訊和可用工具。
  - **子指令：**
    - **`desc`** 或 **`descriptions`**：
      - **說明：** 顯示 MCP 伺服器和工具的詳細說明。
    - **`nodesc`** 或 **`nodescriptions`**：
      - **說明：** 隱藏工具說明，僅顯示工具名稱。
    - **`schema`**：
      - **說明：** 顯示工具設定參數的完整 JSON 結構描述。
  - **鍵盤快速鍵：** 隨時按 **Ctrl+T** 在顯示和隱藏工具說明之間切換。

- **`/memory`**
  - **說明：** 管理 AI 的指令內容（從 `GEMINI.md` 檔案載入的階層式記憶體）。
  - **子指令：**
    - **`add`**：
      - **說明：** 將以下文字新增至 AI 的記憶體。用法：`/memory add <text to remember>`
    - **`show`**：
      - **說明：** 顯示已從所有 `GEMINI.md` 檔案載入的目前階層式記憶體的完整串連內容。這可讓您檢查提供給 Gemini 模型的指令內容。
    - **`refresh`**：
      - **說明：** 從設定位置（全域、專案/上層目錄和子目錄）中找到的所有 `GEMINI.md` 檔案重新載入階層式指令記憶體。此指令會使用最新的 `GEMINI.md` 內容更新模型。
    - **注意：** 有關 `GEMINI.md` 檔案如何構成階層式記憶體的更多詳細資訊，

- **`/restore`**
  - **說明：** 將專案檔案還原到執行工具之前的狀態。這對於復原工具所做的檔案編輯特別有用。如果執行時沒有工具呼叫 ID，它將列出可供還原的檢查點。
  - **用法：** `/restore [tool_call_id]`
 

- **`/settings`**
  - **說明：** 開啟設定編輯器以檢視和修改 Gemini CLI 設定。
  - **詳細資訊：** 此指令提供了一個使用者友好的介面，用於變更控制 Gemini CLI 行為和外觀的設定。它相當於手動編輯 `.gemini/settings.json` 檔案，但具有驗證和引導以防止錯誤。
  - **用法：** 只需執行 `/settings`，編輯器就會開啟。然後，您可以瀏覽或搜尋特定設定、檢視其目前值並根據需要進行修改。某些設定的變更會立即套用，而其他設定則需要重新啟動。

- **`/stats`**
  - **說明：** 顯示目前 Gemini CLI 會話的詳細統計資訊，包括權杖使用量、快取權杖節省量（如果可用）和會話持續時間。注意：快取權杖資訊僅在使用快取權杖時顯示，這種情況發生在 API 金鑰驗證中，但目前在 OAuth 驗證中不會發生。

- [**`/theme`**]
  - **說明：** 開啟一個對話方塊，讓您變更 Gemini CLI 的視覺主題。

- **`/auth`**
  - **說明：** 開啟一個對話方塊，讓您變更驗證方法。

- **`/about`**
  - **說明：** 顯示版本資訊。回報問題時請分享此資訊。

- [**`/tools`**]
  - **說明：** 顯示 Gemini CLI 中目前可用的工具清單。
  - **用法：** `/tools [desc]`
  - **子指令：**
    - **`desc`** 或 **`descriptions`**：
      - **說明：** 顯示每個工具的詳細說明，包括每個工具的名稱及其提供給模型的完整說明。
    - **`nodesc`** 或 **`nodescriptions`**：
      - **說明：** 隱藏工具說明，僅顯示工具名稱。

- **`/privacy`**
  - **說明：** 顯示隱私權聲明，並允許使用者選擇是否同意出於服務改善目的收集其資料。

- **`/quit`** (或 **`/exit`**)
  - **說明：** 結束 Gemini CLI。

- **`/vim`**
  - **說明：** 開啟或關閉 vim 模式。啟用 vim 模式後，輸入區域在 NORMAL 和 INSERT 模式下均支援 vim 風格的導覽和編輯指令。
  - **功能：**
    - **NORMAL 模式：** 使用 `h`、`j`、`k`、`l` 進行導覽；使用 `w`、`b`、`e` 按單字跳轉；使用 `0`、`$`、`^` 跳至行首/行尾；使用 `G`（或 `gg` 表示第一行）跳至特定行
    - **INSERT 模式：** 標準文字輸入，按 escape 鍵返回 NORMAL 模式
    - **編輯指令：** 使用 `x` 刪除、`c` 變更、`i`、`a`、`o`、`O` 插入；複雜操作如 `dd`、`cc`、`dw`、`cw`
    - **計數支援：** 在指令前加上數字（例如 `3h`、`5w`、`10G`）
    - **重複上一個指令：** 使用 `.` 重複上一個編輯操作
    - **持續性設定：** Vim 模式偏好設定會儲存到 `~/.gemini/settings.json` 並在會話之間還原
  - **狀態指示器：** 啟用後，在頁尾顯示 `[NORMAL]` 或 `[INSERT]`

- **`/init`**
  - **說明：** 為了幫助使用者輕鬆建立 `GEMINI.md` 檔案，此指令會分析目前目錄並產生一個量身訂製的內容檔案，讓他們更容易向 Gemini 代理程式提供專案特定的指令。

### 自訂指令

若要快速入門，請參閱下方的 [範例](#範例-一個-純函數-重構指令)。

自訂指令可讓您將喜愛或最常用的提示儲存並重複使用為 Gemini CLI 中的個人捷徑。您可以建立特定於單一專案的指令，或在所有專案中全域可用的指令，從而簡化您的工作流程並確保一致性。

#### 檔案位置與優先順序

Gemini CLI 會從兩個位置探索指令，並依特定順序載入：

1.  **使用者指令 (全域)：** 位於 `~/.gemini/commands/`。這些指令在您正在處理的任何專案中都可用。
2.  **專案指令 (本機)：** 位於 `<your-project-root>/.gemini/commands/`。這些指令特定於目前專案，可以簽入版本控制以與您的團隊共用。

如果專案目錄中的指令與使用者目錄中的指令同名，則**一律使用專案指令。**這允許專案使用專案特定版本覆寫全域指令。

#### 命名和命名空間

指令的名稱由其相對於其 `commands` 目錄的檔案路徑決定。子目錄用於建立命名空間指令，路徑分隔符號 (`/` 或 `
`) 會轉換為冒號 (`:`)。

- `~/.gemini/commands/test.toml` 處的檔案成為 `/test` 指令。
- `<project>/.gemini/commands/git/commit.toml` 處的檔案成為命名空間指令 `/git:commit`。

#### TOML 檔案格式 (v1)

您的指令定義檔案必須以 TOML 格式撰寫，並使用 `.toml` 副檔名。

##### 必要欄位

- `prompt` (字串)：執行指令時將傳送至 Gemini 模型的提示。可以是單行或多行字串。

##### 選用欄位

- `description` (字串)：指令功能的簡短單行說明。此文字將顯示在 `/help` 選單中您的指令旁邊。**如果您省略此欄位，將會從檔名產生一個通用說明。**

#### 處理參數

自訂指令支援兩種強大的方法來處理參數。CLI 會根據您指令 `prompt` 的內容自動選擇正確的方法。

##### 1. 使用 `{{args}}` 的內容感知插入

如果您的 `prompt` 包含特殊預留位置 `{{args}}`，CLI 會將該預留位置替換為使用者在指令名稱後輸入的文字。

此插入的行為取決於其使用位置：

**A. 原始插入 (在 Shell 指令之外)**

在提示的主體中使用時，參數會完全按照使用者輸入的方式插入。

**範例 (`git/fix.toml`)：**

```toml
# 透過以下方式叫用：/git:fix "按鈕未對齊"

description = "產生針對給定問題的修復。"
prompt = "請為此處說明的問題提供程式碼修復：{{args}}。"
```

模型會收到：`請為此處說明的問題提供程式碼修復：「按鈕未對齊」。`

**B. 在 Shell 指令中使用參數 (在 `!{...}` 區塊內)**

當您在 shell 插入區塊 (`!{...}`) 中使用 `{{args}}` 時，參數會在替換前自動進行 **shell 逸出**。這可讓您安全地將參數傳遞給 shell 指令，確保產生的指令語法正確且安全，同時防止指令插入漏洞。

**範例 (`/grep-code.toml`)：**

```toml
prompt = """
請總結 `{{args}}` 模式的發現。

搜尋結果：
!{grep -r {{args}} .}
"""
```

當您執行 `/grep-code It's complicated` 時：

1. CLI 會看到 `{{args}}` 同時在 `!{...}` 內外使用。
2. 外部：第一個 `{{args}}` 會以原始的 `It's complicated` 取代。
3. 內部：第二個 `{{args}}` 會以逸出後的版本取代 (例如，在 Linux 上為 `"It's complicated"`)。
4. 執行的指令是 `grep -r "It's complicated" .`。
5. CLI 會在執行前提示您確認這個確切、安全的指令。
6. 最終的提示會被傳送。

##### 2. 預設參數處理

如果您的 `prompt` **不**包含特殊預留位置 `{{args}}`，CLI 會使用預設行為來處理參數。

如果您為指令提供參數 (例如 `/mycommand arg1`)，CLI 會將您輸入的完整指令附加到提示的結尾，並以兩個換行符號分隔。這可讓模型同時看到原始指令和您剛才提供的特定參數。

如果您**不**提供任何參數 (例如 `/mycommand`)，提示會完全按照原樣傳送給模型，不會附加任何內容。

**範例 (`changelog.toml`)：**

此範例說明如何透過定義模型的角色、說明在哪裡尋找使用者的輸入，以及指定預期的格式和行為來建立一個強大的指令。

```toml
# 在：<project>/.gemini/commands/changelog.toml
# 透過以下方式叫用：/changelog 1.2.0 added "支援預設參數解析。"

description = "將新項目新增至專案的 CHANGELOG.md 檔案。"
prompt = """
# 工作：更新變更日誌

您是此軟體專案的專家維護人員。使用者已叫用指令以將新項目新增至變更日誌。

**使用者的原始指令附加在您的說明下方。**

您的工作是從其輸入中解析 `<version>`、`<change_type>` 和 `<message>`，並使用 `write_file` 工具正確更新 `CHANGELOG.md` 檔案。

## 預期格式
指令遵循此格式：`/changelog <version> <type> <message>`
- `<type>` 必須是下列其中之一：「added」、「changed」、「fixed」、「removed」。

## 行為
1. 讀取 `CHANGELOG.md` 檔案。
2. 尋找指定 `<version>` 的區段。
3. 在正確的 `<type>` 標題下新增 `<message>`。
4. 如果版本或類型區段不存在，請建立它。
5. 嚴格遵守「保留變更日誌」格式。
"""
```

當您執行 `/changelog 1.2.0 added "New feature"` 時，傳送給模型的最終文字將是原始提示，後面接著兩個換行符號和您輸入的指令。

##### 3. 使用 `!{...}` 執行 Shell 指令

您可以透過直接在 `prompt` 中執行 shell 指令並插入其輸出來讓您的指令動態化。這非常適合從您的本機環境收集內容，例如讀取檔案內容或檢查 Git 的狀態。

當自訂指令嘗試執行 shell 指令時，Gemini CLI 現在會在繼續之前提示您確認。這是一項安全措施，以確保只有預期的指令才能執行。

**運作方式：**

1.  **插入指令：** 使用 `!{...}` 語法。
2.  **參數替換：** 如果區塊內存在 `{{args}}`，它會自動進行 shell 逸出 (請參閱上方的 [使用 `{{args}}` 的內容感知插入](#1-使用-args-的內容感知插入))。
3.  **強大的解析：** 解析器可以正確處理包含巢狀大括號的複雜 shell 指令，例如 JSON 承載。**注意：** `!{...}` 內的內容必須有成對的大括號 (`{` 和 `}`)。如果您需要執行包含不成對大括號的指令，請考慮將其包裝在外部指令碼檔案中，並在 `!{...}` 區塊內呼叫該指令碼。
4.  **安全檢查與確認：** CLI 會對最終解析的指令 (在參數逸出和替換後) 執行安全檢查。將會出現一個對話方塊，顯示要執行的確切指令。
5.  **執行與錯誤報告：** 指令會被執行。如果指令失敗，插入到提示中的輸出將包含錯誤訊息 (stderr)，後面接著一個狀態行，例如 `[Shell command exited with code 1]`。這有助於模型了解失敗的內容。

**範例 (`git/commit.toml`)：**

此指令會取得暫存的 git diff，並使用它來要求模型撰寫提交訊息。

````toml
# 在：<project>/.gemini/commands/git/commit.toml
# 透過以下方式叫用：/git:commit

description = "根據暫存的變更產生 Git 提交訊息。"

# 提示使用 !{...} 來執行指令並插入其輸出。
prompt = """
請根據以下 git diff 產生一個傳統提交訊息：

```diff
!{git diff --staged}
```

"""

````

當您執行 `/git:commit` 時，CLI 會先執行 `git diff --staged`，然後在將最終的完整提示傳送給模型之前，將 `!{git diff --staged}` 替換為該指令的輸出。

##### 4. 使用 `@{...}` 插入檔案內容

您可以使用 `@{...}` 語法直接將檔案內容或目錄清單嵌入到您的提示中。這對於建立對特定檔案進行操作的指令很有用。

**運作方式：**

- **檔案插入**：`@{path/to/file.txt}` 會被 `file.txt` 的內容取代。
- **多峰支援**：如果路徑指向支援的圖片 (例如 PNG、JPEG)、PDF、音訊或影片檔案，它將被正確編碼並作為多峰輸入插入。其他二進位檔案會被妥善處理並略過。
- **目錄清單**：`@{path/to/dir}` 會被遍歷，目錄和所有子目錄中存在的每個檔案都會被插入到提示中。如果啟用，這會尊重 `.gitignore` 和 `.geminiignore`。
- **工作區感知**：指令會在目前目錄和任何其他工作區目錄中搜尋路徑。如果絕對路徑在工作區內，則允許使用絕對路徑。
- **處理順序**：使用 `@{...}` 的檔案內容插入會在 shell 指令 (`!{...}`) 和參數替換 (`{{args}}`) _之前_ 處理。
- **解析**：解析器要求 `@{...}` 內的內容 (路徑) 具有成對的大括號 (`{` 和 `}`)。

**範例 (`review.toml`)：**

此指令會插入一個_固定的_最佳實踐檔案 (`docs/best-practices.md`) 的內容，並使用使用者的參數來提供審查的內容。

```toml
# 在：<project>/.gemini/commands/review.toml
# 透過以下方式叫用：/review FileCommandLoader.ts

description = "使用最佳實踐指南審查提供的內容。"
prompt = """
您是一位專家程式碼審查員。

您的任務是審查 {{args}}。

在提供您的審查時，請使用以下最佳實踐：

@{docs/best-practices.md}
"""
```

當您執行 `/review FileCommandLoader.ts` 時，`@{docs/best-practices.md}` 預留位置會被該檔案的內容取代，而 `{{args}}` 會被您提供的文字取代，然後才會將最終的提示傳送給模型。

---

#### 範例：一個「純函數」重構指令

讓我們建立一個全域指令，要求模型重構一段程式碼。

**1. 建立檔案和目錄：**

首先，確保使用者指令目錄存在，然後建立一個 `refactor` 子目錄用於組織，以及最終的 TOML 檔案。

```bash
mkdir -p ~/.gemini/commands/refactor
touch ~/.gemini/commands/refactor/pure.toml
```

**2. 將內容新增至檔案：**

在您的編輯器中開啟 `~/.gemini/commands/refactor/pure.toml` 並新增以下內容。為了最佳實踐，我們加入了選用的 `description`。

```toml
# 在：~/.gemini/commands/refactor/pure.toml
# 此指令將透過以下方式叫用：/refactor:pure

description = "要求模型將目前內容重構為純函數。"

prompt = """
請分析我在目前內容中提供的程式碼。
將其重構為純函數。

您的回應應包含：
1. 重構後的純函數程式碼區塊。
2. 您所做關鍵變更的簡要說明，以及它們為何有助於純度。
"""
```

**3. 執行指令：**

就是這樣！您現在可以在 CLI 中執行您的指令。首先，您可以將檔案新增至內容，然後叫用您的指令：

```
> @my-messy-function.js
> /refactor:pure
```

Gemini CLI 接著會執行您在 TOML 檔案中定義的多行提示。

## At 指令 (`@`)

At 指令用於將檔案或目錄的內容包含為您給 Gemini 的提示的一部分。這些指令包含 git 感知篩選。

- **`@<path_to_file_or_directory>`**
  - **說明：** 將指定檔案或檔案的內容插入到您目前的提示中。這對於詢問有關特定程式碼、文字或檔案集合的問題很有用。
  - **範例：**
    - `@path/to/your/file.txt 解釋這段文字。`
    - `@src/my_project/ 總結此目錄中的程式碼。`
    - `這個檔案是關於什麼的？ @README.md`
  - **詳細資訊：**
    - 如果提供單一檔案的路徑，則會讀取該檔案的內容。
    - 如果提供目錄的路徑，指令會嘗試讀取該目錄和任何子目錄中檔案的內容。
    - 路徑中的空格應使用反斜線逸出 (例如 `@My\ Documents/file.txt`)。
    - 指令在內部使用 `read_many_files` 工具。內容會被擷取，然後在傳送給 Gemini 模型之前插入到您的查詢中。
    - **Git 感知篩選：** 預設情況下，會排除 git 忽略的檔案 (例如 `node_modules/`、`dist/`、`.env`、`.git/`)。可以透過 `fileFiltering` 設定變更此行為。
    - **檔案類型：** 該指令適用於基於文字的檔案。雖然它可能會嘗試讀取任何檔案，但為了確保效能和相關性，底層的 `read_many_files` 工具可能會略過或截斷二進位檔案或非常大的檔案。該工具會指示是否略過了檔案。
  - **輸出：** CLI 將顯示一則工具呼叫訊息，指出已使用 `read_many_files`，以及一則詳述狀態和已處理路徑的訊息。

- **`@` (單獨的 at 符號)**
  - **說明：** 如果您輸入一個沒有路徑的單獨 `@` 符號，查詢會按原樣傳遞給 Gemini 模型。如果您在提示中專門討論 `@` 符號，這可能很有用。

### `@` 指令的錯誤處理

- 如果在 `@` 之後指定的路徑找不到或無效，將會顯示錯誤訊息，並且查詢可能不會傳送給 Gemini 模型，或者會在沒有檔案內容的情況下傳送。
- 如果 `read_many_files` 工具遇到錯誤 (例如權限問題)，也會報告此錯誤。

## Shell 模式與傳遞指令 (`!`) 

`!` 前置詞可讓您直接從 Gemini CLI 內部與系統的 shell 互動。

- **`!<shell_command>`**
  - **說明：** 在 Linux/macOS 上使用 `bash` 或在 Windows 上使用 `cmd.exe` 執行給定的 `<shell_command>`。指令的任何輸出或錯誤都會顯示在終端機中。
  - **範例：**
    - `!ls -la` (執行 `ls -la` 並返回 Gemini CLI)
    - `!git status` (執行 `git status` 並返回 Gemini CLI)

- **`!` (切換 shell 模式)**
  - **說明：** 單獨輸入 `!` 會切換 shell 模式。
    - **進入 shell 模式：**
      - 啟用時，shell 模式會使用不同的顏色和「Shell 模式指示器」。
      - 在 shell 模式下，您輸入的文字會直接被解譯為 shell 指令。
    - **退出 shell 模式：**
      - 退出後，UI 會恢復其標準外觀，並恢復正常的 Gemini CLI 行為。

- **所有 `!` 用法的注意事項：** 您在 shell 模式下執行的指令具有與直接在終端機中執行它們相同的權限和影響。

- **環境變數：** 當透過 `!` 或在 shell 模式下執行指令時，會在子處理程序的環境中設定 `GEMINI_CLI=1` 環境變數。這可讓指令碼或工具偵測它們是否在 Gemini CLI 中執行。