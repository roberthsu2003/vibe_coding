# 摘要

本報告將深入探討 Cursor AI 編輯器中的自訂功能，旨在提供一份從入門到精通的完整指南。我們將從使用者直接查詢的自訂命令 (`/commands`) 開始，詳細解析其設定方法與應用場景。接著，報告將進一步揭示更為強大的 `Rules` 系統，闡明其與命令的區別與協同作用，並指導使用者如何利用 `.mdc` 檔案語法來精確控制 AI 的行為。最後，本報告將整合社群的最佳實踐、高階應用技巧及常見問題的解決方案，協助開發者將 Cursor 轉化為一個真正個人化、高效率的 AI 開發夥伴。

---

## 第一章：深入理解 Cursor 自訂命令 (Commands)

### 1.1 命令的核心概念

自訂命令是 Cursor AI 中用於建立可重複使用工作流程的核心功能。其本質是預先定義好的 Markdown 檔案，可透過在聊天輸入框中輸入 `/` 前綴來觸發 1。此功能旨在將一系列指令或一個結構化的提示（Prompt）範本封裝起來，從而標準化團隊流程並顯著提高常見任務的執行效率 1。

對於個人開發者而言，命令是將複雜或頻繁使用的指令簡化為單一觸發詞的利器，極大地降低了與 AI 互動時的認知負荷。對於團隊協作，命令的價值更為凸顯。它能夠確保團隊成員在執行如程式碼審查、建立新功能或提交拉取請求（Pull Request）等關鍵任務時，遵循一套統一、標準化的操作流程 1。

更深一層來看，自訂命令不僅是自動化工具，更可被視為一種「可執行的文件」（Executable Documentation）。傳統的專案文件（例如 `CONTRIBUTING.md`）需要開發者手動閱讀、理解並遵循。而 Cursor 的命令功能，則將這些流程性文件直接轉化為 AI 可理解並執行的指令集。例如，一個名為 `/code-review-checklist` 的命令，將靜態的審查清單文件，變成了可在開發環境中被 AI 代理（Agent）即時調用並協助執行的互動式工作流程，這徹底改變了開發者與專案規範的互動模式。

### 1.2 創建您的第一個命令：步驟詳解

建立自訂命令的過程直觀明瞭，主要涉及在指定的目錄中創建 Markdown 檔案。Cursor 會在兩個特定位置偵測命令檔案 1：

1. **專案命令 (Project commands):** 儲存在專案根目錄下的 `.cursor/commands` 資料夾中。這些命令與專案版本控制系統（如 Git）一同管理，專屬於該專案，非常適合定義特定於程式碼庫的工作流程，例如執行特定的測試套件或遵循該專案的程式碼產生範本。
2. **全域命令 (Global commands):** 儲存在使用者主目錄下的 `~/.cursor/commands` 資料夾中。這些命令適用於所有專案，是建立個人化開發環境的關鍵。適合存放通用的 Git 操作、個人偏好的程式碼重構模式或寫作風格指令 1。

當使用者在聊天輸入框中輸入 `/` 時，Cursor 會即時掃描這兩個目錄，並在彈出選單中列出所有可用的命令，方便使用者快速選取 1。

**創建步驟如下：**

1. **選擇位置並建立目錄：** 根據需求，在您的專案根目錄建立 `.cursor/commands` 資料夾，或在您的使用者主目錄（Home Directory）建立 `~/.cursor/commands` 資料夾。
2. **新增 Markdown 檔案：** 在該目錄下，新增以 `.md` 為副檔名的檔案。
3. **遵循命名規範：** 檔案名稱應具備高描述性，以便於識別。官方文件建議使用如 `review-code.md` 或 `write-tests.md` 的名稱 2。採用「動詞-名詞」的格式（例如

`run-all-tests-and-fix.md`）是一種良好的實踐，能讓命令列表更加清晰易懂。

### 1.3 精心撰寫命令內容：從範本到實踐

命令的威力取決於其 Markdown 檔案的內容品質。這些內容直接作為給予 AI 的指令。官方文件提供了幾個極具代表性的範例，展示了如何透過結構化的 Markdown 來引導 AI 完成複雜任務 1。

一個核心的觀察是，這些高效的命令範本普遍利用了 Markdown 的結構化元素，如標題、列表和清單。這揭示了一個重要原則：提供給大型語言模型的指令越是結構化，其產出的結果就越可預測、品質越高。相較於模糊的自然語言描述，AI 在處理條理分明、層次清晰的指令時表現更為出色，因為這減少了指令的歧義性，並為 AI 的思考過程提供了一個清晰的框架。

以下是官方範例的內容及其分析：

**範例一：程式碼審查清單 (Code Review Checklist)**

# Code Review Checklist

## Overview

Comprehensive checklist for conducting thorough code reviews to ensure quality, security, and maintainability.

## Review Categories

### Functionality

- [ ] Code does what it's supposed to do
- [ ] Edge cases are handled
- [ ] Error handling is appropriate
- [ ] No obvious bugs or logic errors

### Code Quality

- [ ] Code is readable and well-structured
- [ ] Functions are small and focused
- [ ] Variable names are descriptive
- **分析：** 此命令利用 Markdown 的標題 (`#`, `##`) 和清單 (`- [ ]`) 語法，建立了一個層次分明的審查流程。這不僅是給 AI 的指令，要求它從這些維度進行分析，同時也為執行審查的開發者提供了一個直觀的提醒，確保審查的全面性。

**範例二：建立新功能 (Setup New Feature)**

# Setup New Feature

## Overview

Systematically set up a new feature from initial planning through to implementation structure.

## Steps

1. **Define requirements**
    - Clarify feature scope and goals
    - Identify user stories and acceptance criteria
    - Plan technical approach
1. **Create feature branch**
    - Branch from main/develop
    - Set up local development environment
    - Configure any new dependencies
1. **Plan architecture**
    - Design data models and APIs
    - Plan UI components and flow
    - Consider testing strategy

## Feature Setup Checklist

- [ ] Requirements documented
- [ ] User stories written
- [ ] Technical approach planned
- [ ] Feature branch created
- [ ] Development environment ready
- **分析：** 此命令將一個複雜的開發任務分解為「定義需求」、「建立分支」和「規劃架構」等邏輯步驟。每個步驟下又包含具體的子任務清單。這種結構化的方法引導 AI 進行系統性思考，而不是直接跳入程式碼實現，有助於產出更有條理、更完整的規劃。

其他範例，如 `Security Audit` 和 `Create Pull Request`，同樣遵循此模式，將專業流程範本化，確保每次執行時都能涵蓋所有關鍵檢查點，從而提升工作品質與一致性 1。

---

## 第二章：超越命令—掌握規則 (Rules) 的強大威力

### 2.1 命令與規則的區別與協同

雖然命令功能強大，但 Cursor 還提供了另一套更為底層且持久的自訂機制——規則（Rules）。理解二者的區別與協同關係，是從入門使用者邁向進階專家的關鍵一步。

- **命令 (Commands):** 是透過 `/` **手動觸發**的、針對**特定任務**的可重複使用工作流程 1。它們是即時的、一次性的指令。
- **規則 (Rules):** 是提供給 AI 代理（Agent）和內聯編輯（Inline Edit）的**系統級指令**。它們是專案的**持久性上下文**、偏好或工作流程，會**自動或半自動地**在背景生效 4。

一個清晰的比喻是：命令如同「一次性的命令行工具」，您在需要時明確調用它來完成某項工作；而規則則像是「設定檔」（如 `.bashrc` 或 `.editorconfig`），它定義了環境的預設行為和長期遵循的準則。命令是「做這件事」，而規則是「以後做所有事情時，都要記住這件事」。

進一步分析，Cursor 的自訂功能構成了一個分層的 AI 指導系統：

1. **全域使用者規則 (User Rules):** 位於最底層，定義了適用於所有專案的個人偏好，如溝通風格 4。
2. **專案規則 (Project Rules):** 位於中間層，定義了特定程式碼庫的團隊規範和架構決策，其優先級高於全域規則 4。
3. **命令 (Commands):** 位於最頂層，是針對特定任務的即時指令，具有最高的優先級，但在該次任務結束後即失效 1。

理解這個層次結構，有助於開發者在正確的層級上應用自訂，避免將專案特定規範放入全域規則等混淆情況。

### 2.2 規則系統詳解

規則系統的物理結構主要圍繞 `.cursor/rules` 目錄和 `.mdc` 檔案格式展開。

- **專案規則目錄:** 專案規則儲存在專案根目錄下的 `.cursor/rules` 資料夾中。每個規則都是一個獨立的檔案，便於版本控制和團隊共享 4。Cursor 還支援巢狀規則，即在子目錄中也可以建立

    `.cursor/rules`，其作用域將僅限於該子目錄及其後代 4。

- **`.mdc` 檔案格式:** 規則檔案採用 `.mdc`（Markdown with Components）格式。這是一種擴充的 Markdown 格式，其主要優勢在於檔案開頭支援 YAML frontmatter 區塊，用於定義規則的元數據和觸發條件 4。
- **`AGENTS.md` 替代方案:** 對於較簡單的專案指令，Cursor 提供了一個更輕量級的替代方案：在專案根目錄或子目錄中建立一個名為 `AGENTS.md` 的檔案。它是一個純 Markdown 檔案，不支援複雜的元數據和觸發邏輯，但非常適合存放易於閱讀和維護的通用指令 4。
- **舊格式 (`.cursorrules`):** 舊有的 `.cursorrules` 檔案格式仍被支援，但已被官方標記為棄用（Legacy）。建議所有新專案都採用功能更強大、結構更清晰的 `.cursor/rules` 和 `.mdc` 格式 4。

### 2.3 規則的剖析：YAML Frontmatter 語法精通

`.mdc` 檔案的威力核心在於其 YAML frontmatter。透過設定 `description`、`globs` 和 `alwaysApply` 這三個關鍵欄位，可以精確控制規則的啟動時機和方式 5。

- `description` (string): 提供給 AI 代理的文字描述。當規則需要由 AI 根據上下文決定是否啟用時（即 Agent Requested 類型），此欄位至關重要。AI 會根據此描述的相關性來判斷是否要加載該規則的完整內容 5。
- `globs` (string): 一個或多個以逗號分隔的檔案匹配模式（glob pattern）。當聊天或編輯的上下文中包含了與此模式匹配的檔案時，該規則會被自動附加（Auto Attached）4。
- `alwaysApply` (boolean): 如果設為 `true`，則此規則將被無條件地應用於每一次 AI 互動中，忽略 `globs` 欄位的設定 5。

這些欄位的不同組合，決定了規則的四種主要啟動類型，如下表所示：

| **規則類型**            | **`description`** | **`globs`** | **`alwaysApply`** | **啟動行為**                          | **使用場景範例**                                     |
| ------------------- | ----------------- | ----------- | ----------------- | --------------------------------- | ---------------------------------------------- |
| **Always**          | 可選                | 忽略          | `true`            | 總是包含在模型上下文中。                      | 全域程式碼風格：「所有變數命名總是使用蛇形命名法 (snake_case)。」        |
| **Auto Attached**   | 可選                | **必需**      | `false`           | 僅當上下文中引用了匹配 glob 模式的檔案時才包含。       | 框架特定指南：一條針對 React 元件的規則，僅在 `.tsx` 檔案處於上下文中時應用。 |
| **Agent Requested** | **必需**            | 未設定         | `false`           | AI 代理可見，由其根據描述的相關性決定是否包含。         | 複雜工作流程：一條關於資料庫遷移的規則，AI 僅在使用者查詢與變更資料庫結構相關時才使用。  |
| **Manual**          | 未設定               | 未設定         | `false`           | 僅當使用者在聊天中透過 `@ruleName` 明確引用時才包含。 | 利基工具：一條針對不常用內部函式庫 API 的規則，僅在需要時手動調用。           |

這張表格為創建和除錯規則提供了一個清晰的速查參考，有助於避免常見的配置陷阱，例如同時設定 `globs` 和 `alwaysApply: true` 並期望 `globs` 生效的錯誤認知 5。

### 2.4 全域使用者規則 (User Rules)

除了專案級別的規則，Cursor 還允許使用者在全域範圍內設定個人偏好。這些「使用者規則」在 Cursor 的設定介面中定義，適用於所有專案 4。

它們以純文字形式存在，非常適合用來設定 AI 助手的「個性」或通用的編碼慣例。例如，可以設定以下規則來塑造 AI 的溝通風格 4：

- `Please reply in a concise style. Avoid unnecessary repetition or filler language.` (請以簡潔的風格回覆。避免不必要的重複或填充語言。)
- `Always prioritize code readability and maintainability in your suggestions.` (在您的建議中，始終優先考慮程式碼的可讀性和可維護性。)

---

## 第三章：高階應用與最佳實踐

### 3.1 結合上下文 (`@` 符號) 增強命令與規則的效果

Cursor 的自訂功能之所以強大，不僅在於其靜態的指令定義，更在於其與動態上下文的結合能力。透過 `@` 符號，使用者可以將程式碼庫中的即時資訊注入到命令和規則中，將 AI 從一個通用的指令執行者，轉變為一個具備深度上下文感知能力的代理 9。

可用的上下文符號包括 `@Files`、`@Folders`、`@Code`（引用特定函式或類別）、`@Docs`（引用已添加的文件）、`@Git`（引用提交或分支差異）、`@Web`（進行網路搜尋）以及 `@Past Chats`（引用過去的對話）等 10。

這種結合的威力體現在：

- **動態規則：** 一條規則可以包含對範本檔案的引用，如 `@service-template.ts` 4。當這條規則被觸發時，AI 會自動讀取該範本檔案的最新內容作為其執行依據。這意味著更新範本檔案即可更新 AI 的行為，無需修改規則本身。
- **智慧命令：** 一個 `/create-pr` 命令可以提示 AI：「請使用 `@Git @Branch` 來分析當前分支的所有變更，並基於這些變更自動生成一份遵循我們範本的拉取請求描述。」

這種模式的核心價值在於，最有效的自訂並非編寫冗長的靜態指令，而是教會 AI **如何利用工具 (`@` 符號) 自行尋找最新、最相關的資訊**。這使得自動化流程更具彈性和魯棒性，能夠適應不斷變化的程式碼庫狀態。

### 3.2 社群智慧結晶：從 `awesome-cursorrules` 學習

從零開始編寫一套完善的規則集可能頗具挑戰性。幸運的是，開源社群提供了寶貴的資源。`PatrickJS/awesome-cursorrules` 是一個 GitHub 儲存庫，它匯集了大量由社群貢獻的、針對不同技術棧（如 React, Next.js, Python 等）和特定用途（如測試、文件撰寫）的規則檔案 12。

探索這個儲存庫是學習和快速應用規則的最佳途徑。以下是幾個高品質範例的分析：

- 案例分析 1: Next.js + Tailwind + TypeScript 12
    - 這類規則通常會定義詳細的開發規範，例如：元件的檔案結構、Server/Client Components 的使用時機、資料獲取的首選模式（如 `fetch` in Server Components）、Tailwind CSS 的類名排序約定，以及 TypeScript 的類型定義風格。透過應用這類規則，可以確保 AI 生成的程式碼與專案現有的、符合現代前端最佳實踐的程式碼風格保持高度一致。
- 案例分析 2: Git 提交訊息 12
    - 旨在強制執行「Conventional Commits」規範的規則是另一個常見範例。這類規則會向 AI 提供一個標準的提交訊息範本（如 `feat(scope): description`），並附上正面和負面的範例，指導 AI 根據程式碼變更的性質（新功能、修復、重構等）撰寫出標準化、易於機器解析的提交訊息。
- 案例分析 3: 使用 Cypress 進行 API 測試 12
    - 為測試框架建立規則可以極大提升測試編寫效率。這類規則會指導 AI 遵循特定的測試模式，例如 Arrange-Act-Assert (AAA)，並告知 AI 如何使用專案中已有的測試輔助函式或固件（fixtures），確保新生成的測試案例與現有測試套件的風格和結構保持一致。

### 3.3 撰寫高效規則的最佳實踐

綜合官方文件和社群的實踐經驗，可以總結出以下幾點撰寫高效規則的最佳實踐 4：

- **保持專注與簡潔 (Keep rules focused and scoped):** 避免建立一個龐大而臃腫的「萬能」規則檔案。應將其分解為多個小的、功能單一、可組合的規則。例如，將樣式規則和測試規則分開。官方建議規則長度最好保持在 500 行以內 4。
- **提供具體範例 (Provide concrete examples):** AI 更擅長從範例中學習。與其給出抽象的指令如「請使用我們的 API 模式」，不如直接在規則中透過 `@` 符號引用一個寫得很好的範例檔案，並指示 AI「請參考 `@api-example.ts` 的風格來實現新的 API 端點」4。
- **明確禁止事項 (Define "what not to do"):** 除了告知 AI 該做什麼，明確指出不該做什麼也同樣重要。這有助於避免 AI 產生不必要的或有害的行為。例如：「不要執行 `npm start`，因為開發伺服器總是在運行」或「除非被明確要求，否則不要編寫文件註解」13。
- **定期強化與提醒 (Periodic Rule Reinforcement):** 在一次長對話中，AI 模型可能會逐漸偏離或「忘記」初始設定的規則。在對話過程中，可以偶爾插入提醒，如「請記住我們的專案規則」。一個更進階的技巧是，在規則中要求 AI 在其每個回應的末尾註明它應用了哪些規則，這使得規則的執行情況變得透明可追蹤 13。
- **擁抱測試驅動開發 (Test-Driven Development):** 一種極其強大的模式是建立一條規則或命令，指示 AI 遵循 TDD 流程：「首先為需求編寫一個失敗的測試，然後編寫能讓測試通過的最小化實作程式碼，最後運行測試以驗證結果」14。這種方法利用了 AI 快速生成程式碼的能力，同時透過測試的約束來確保產出程式碼的正確性。
- **善用 YOLO 模式 (Use YOLO mode):** 對於那些可以透過自動化測試來完全驗證的任務，可以啟用 Cursor 的 YOLO（You Only Look Once）模式。在該模式下，AI 會在修改程式碼後自動運行測試，如果測試通過，它可以無需人工確認便直接提交程式碼，從而實現更高程度的端到端自動化 14。

### 3.4 探索新功能：自訂模式 (Custom Modes)

自訂模式（Custom Modes）是 Cursor 正在測試的一項新功能，它允許使用者將特定的工具集和系統指令打包成一個可切換的 AI「人格」或「模式」15。例如，使用者可以創建：

- **Learn 模式:** 啟用所有搜尋工具，並指示 AI 優先提供概念的完整解釋。
- **Refactor 模式:** 僅啟用程式碼編輯工具，並指示 AI 專注於改善程式碼結構，而不新增任何新功能。
- **Debug 模式:** 啟用所有搜尋、終端和編輯工具，並指示 AI 在提出修復方案前，必須先進行徹底的問題調查。

相較於一次性的「命令」和持續生效的「規則」，「模式」更像是為 AI 代理選擇一個當前的「角色」。這個角色決定了它可用的工具範疇和整體的行為目標。這可能是 Cursor 未來自訂化功能的一個重要演進方向，旨在將零散的規則和工具配置，整合成更易於管理和切換的單元 15。

---

## 第四章：疑難排解與調校

### 4.1 為何我的規則沒有生效？

「我寫了規則，但 AI 並沒有遵循它」是使用者最常遇到的問題 17。這個問題的根源通常在於對 Cursor 內部 AI 架構的誤解。Cursor 的 AI 系統並非單一模型，而是一個兩層架構：

1. **決策代理 (Agent):** 這是使用者在聊天介面中直接互動的 AI。它的主要職責是理解使用者的意圖，分析當前的上下文（包括程式碼、對話歷史等），然後從所有可用的專案規則中，**選擇**它認為與當前任務最相關的規則 7。
2. **生成模型 (Model):** 這是底層的、負責實際生成程式碼或文字的大型語言模型（如 GPT-5 或 Claude-4）。

問題的關鍵在於，如果上層的「決策代理」沒有選擇您的規則並將其內容放入上下文，那麼底層的「生成模型」就根本不知道這條規則的存在，自然也無法遵循它 7。因此，除錯的焦點不應僅僅是規則的內容本身，更應該是：「為什麼決策代理沒有選擇我的規則？」

常見原因包括：

- 對於 **Agent Requested** 類型的規則，其 `description` 寫得不夠清晰或與使用者查詢的語義不匹配，導致代理認為它不相關 7。
- 對於 **Auto Attached** 類型的規則，其 `globs` 模式不正確，沒有匹配到當前上下文中的任何檔案。
- 規則的內容與使用者的即時指令產生了衝突，AI 優先遵循了更具體的即時指令。

理解這個兩層架構是有效除錯的基礎。編寫規則時，不僅要考慮生成模型如何理解指令，還要考慮決策代理如何篩選指令。

### 4.2 與 AI 對話：診斷規則執行問題

基於對兩層架構的理解，可以採用一種對話式的方法來診斷和除錯規則的執行問題。這種方法將 AI 視為一個可被「偵錯」的系統，透過一系列探測性問題來揭示其內部的決策過程 17。

一個標準的除錯流程如下：

1. **確認感知 (Check Awareness):** 首先確認決策代理是否知道規則的存在。可以提問：「你目前知道哪些可用的專案規則？請列出它們的名稱。」或更具體地：「你能看到名為 `my-specific-rule.mdc` 的規則嗎？」
2. **確認應用 (Check Application):** 如果代理確認知道該規則，但其行為不符，可以追問：「在你上一個回應中，你是否應用了 `my-specific-rule.mdc`？」
3. **探究原因 (Probe Reasoning):** 如果代理回答沒有應用該規則，這是最關鍵的一步。追問：「你為什麼決定不應用那條規則？」這個問題通常會迫使代理闡述其決策邏輯，例如它可能會回答「我認為該規則的內容與你當前關於修復 bug 的請求無關」，從而揭示出問題所在——可能是 `description` 不夠精確，或是規則的適用範圍定義得過於狹窄。

透過這種互動式的診斷，可以有效地定位問題是出在規則的發現階段還是應用階段，並據此進行針對性的修改。

### 4.3 效能與網路問題排查

有時，自訂功能不工作或行為異常，其根源並非指令本身，而是底層的環境配置問題。

- **網路問題:** Cursor 的核心 AI 功能（如 Tab 自動完成和內聯編輯）依賴 HTTP/2 協議以實現高效的串流回應。然而，許多企業網路、VPN 或代理伺服器（如 Zscaler）可能會出於安全策略而阻止 HTTP/2 流量 18。
    - **解決方案:** 使用者應首先運行 Cursor 設定中的內建網路診斷工具（Cursor Settings > Network > Run Diagnostics）18。如果檢測到問題，可以在應用程式設定中搜尋

        `HTTP/2`，並啟用「Disable HTTP/2」選項，這會強制 Cursor 回退到相容性更好的 HTTP/1.1 協議 18。

- **資源消耗:** 高 CPU 或 RAM 使用率可能導致編輯器卡頓，影響 AI 功能的回應速度。這通常不是 Cursor 核心的問題，而是由安裝的某個擴充功能引起的 18。
    - **解決方案:** 使用 Cursor 內建的進程瀏覽器（Help > Open Process Explorer），檢查哪個進程（特別是 extensionHost）佔用了過多資源，並嘗試禁用可疑的擴充功能。
- **程式碼索引:** AI 對專案的理解依賴於一個在背景建立的程式碼索引。如果專案的檔案結構發生了重大變化（例如新增、刪除或移動了大量檔案），而索引未能及時更新，AI 可能會基於過時的資訊提供不準確的回應 8。
    - **解決方案:** 在設定中手動觸發索引的重新同步（Cursor Settings > Resync Index），確保 AI 擁有對程式碼庫最新的、最全面的認知。

---

## 結論：打造您的個人化 AI 開發夥伴

Cursor 的自訂功能為開發者提供了一個從簡單到複雜、層次分明的完整體系，使其不僅僅是一個編輯器，更是一個可被深度塑造的 AI 開發夥伴。

建議的演進路徑是：

1. 從易於上手的 **`/commands`** 開始，將日常重複性任務（如程式碼審查、建立 PR）標準化，立即提升個人和團隊的效率。
2. 隨著對專案理解的深入，逐步引入專案級的 **`Rules`**，將團隊的編碼規範、架構決策和領域知識固化下來，確保 AI 生成的程式碼與專案風格保持一致。
3. 最終，透過結合動態的 **`@` 上下文符號**和社群分享的**最佳實踐**，將靜態的指令轉化為能夠感知程式碼庫即時狀態、自主尋找資訊的智慧代理。

從一個通用的 AI 助手，到一個深度理解特定專案、遵循特定工作流程、並能高效自動化複雜任務的個人化夥伴——這條路徑的核心在於持續的實驗、分享和完善。開發者應當積極地創建、迭代和共享自己的命令與規則集，因為這是一個與 AI 共同成長、不斷演進的過程。

