# 4.4 測試生成 (test)

## 簡介

自動化測試是確保代碼品質的重要環節，但撰寫測試常常耗時且繁瑣。Claude Code CLI 能夠智慧地為你的代碼生成高品質的測試案例，包括單元測試、整合測試和端對端測試。

透過 Claude 的協助，你可以快速建立完整的測試覆蓋，不僅節省時間，還能學習如何撰寫好的測試案例。

## 基本用法

### 為單一檔案生成測試

```bash
# 基本測試生成
claude "為 calculator.js 生成測試檔案"

# 指定測試框架
claude "用 Jest 為 user.service.js 生成單元測試"
```

### 為整個模組生成測試

```bash
# 生成多個測試檔案
claude "為 src/api 目錄下的所有檔案生成測試"

# 只為缺少測試的檔案生成
claude "檢查哪些檔案沒有測試，並為它們生成測試"
```

## 測試類型

### 1. 單元測試 (Unit Tests)

測試單一函數或方法的功能。

```bash
claude "為 utils/validation.js 中的所有函數生成單元測試"
```

**生成範例：**
```javascript
// validation.test.js
describe('Validation Utils', () => {
  describe('isValidEmail', () => {
    it('should return true for valid email', () => {
      expect(isValidEmail('user@example.com')).toBe(true);
    });

    it('should return false for invalid email', () => {
      expect(isValidEmail('invalid-email')).toBe(false);
    });

    it('should handle empty string', () => {
      expect(isValidEmail('')).toBe(false);
    });

    it('should handle null and undefined', () => {
      expect(isValidEmail(null)).toBe(false);
      expect(isValidEmail(undefined)).toBe(false);
    });
  });
});
```

### 2. 整合測試 (Integration Tests)

測試多個模組之間的互動。

```bash
claude "為 user.service.js 生成整合測試，包含資料庫互動"
```

**生成範例：**
```javascript
describe('User Service Integration', () => {
  beforeEach(async () => {
    await setupTestDatabase();
  });

  afterEach(async () => {
    await cleanupTestDatabase();
  });

  it('should create user and save to database', async () => {
    const userData = { name: 'Test User', email: 'test@example.com' };
    const user = await userService.createUser(userData);

    expect(user.id).toBeDefined();
    const savedUser = await db.users.findById(user.id);
    expect(savedUser.name).toBe(userData.name);
  });
});
```

### 3. 端對端測試 (E2E Tests)

測試完整的使用者流程。

```bash
claude "為登入流程生成 E2E 測試，使用 Cypress"
```

### 4. API 測試

```bash
claude "為所有 Express 路由生成 API 測試"
```

**生成範例：**
```javascript
describe('User API', () => {
  it('GET /api/users should return all users', async () => {
    const response = await request(app)
      .get('/api/users')
      .expect(200);

    expect(response.body).toBeInstanceOf(Array);
    expect(response.body.length).toBeGreaterThan(0);
  });

  it('POST /api/users should create new user', async () => {
    const newUser = { name: 'John', email: 'john@example.com' };
    const response = await request(app)
      .post('/api/users')
      .send(newUser)
      .expect(201);

    expect(response.body.name).toBe(newUser.name);
  });
});
```

### 5. 前端元件測試

```bash
# React 元件測試
claude "用 React Testing Library 為 LoginForm 元件生成測試"

# Vue 元件測試
claude "用 Vue Test Utils 為 UserProfile 元件生成測試"
```

## 測試覆蓋策略

### 正常情況測試

```bash
claude "生成測試，涵蓋所有正常使用情況"
```

### 邊界條件測試

```bash
claude "生成測試，涵蓋邊界條件：
- 空陣列
- 最大/最小值
- 特殊字元
- 空字串"
```

### 錯誤處理測試

```bash
claude "生成測試，驗證錯誤處理：
- 無效輸入
- 網路錯誤
- 資料庫錯誤
- 權限錯誤"
```

### 非同步操作測試

```bash
claude "為這個 async 函數生成測試，包含：
- 成功情況
- Promise rejection
- Timeout 處理"
```

## 實用範例

### 範例 1：完整測試套件

```bash
claude "為 payment.service.js 生成完整的測試套件，包括：
1. 所有公開方法的單元測試
2. 與支付閘道的整合測試
3. 錯誤處理測試
4. Mock 外部 API 呼叫"
```

### 範例 2：測試驅動開發 (TDD)

```bash
# 先生成測試
claude "為一個尚未實作的 sorting 函數生成測試案例"

# 再實作功能
claude "根據這些測試案例，實作 sorting 函數"
```

### 範例 3：提升測試覆蓋率

```bash
# 檢查覆蓋率
npm test -- --coverage

# 為未涵蓋的部分生成測試
claude "檢查測試覆蓋率報告，為未涵蓋的代碼生成測試"
```

### 範例 4：重構現有測試

```bash
claude "重構這些測試，改善可讀性並減少重複代碼"
```

## 測試框架支援

### JavaScript/TypeScript

```bash
# Jest
claude "用 Jest 生成測試" --framework jest

# Mocha + Chai
claude "用 Mocha 和 Chai 生成測試" --framework mocha

# Vitest
claude "用 Vitest 生成測試" --framework vitest
```

### Python

```bash
# pytest
claude "用 pytest 為這個 Python 模組生成測試"

# unittest
claude "用 unittest 框架生成測試"
```

### 其他語言

```bash
# Go
claude "用 Go testing 套件生成測試"

# Java
claude "用 JUnit 生成測試"

# Rust
claude "生成 Rust 單元測試"
```

## Mock 和 Stub

### Mock 外部依賴

```bash
claude "生成測試，Mock 以下外部依賴：
- 資料庫連線
- HTTP 請求
- 檔案系統操作"
```

**生成範例：**
```javascript
jest.mock('../database');
jest.mock('axios');

describe('User Service', () => {
  it('should fetch user from API', async () => {
    axios.get.mockResolvedValue({
      data: { id: 1, name: 'Test User' }
    });

    const user = await userService.fetchUser(1);
    expect(user.name).toBe('Test User');
  });
});
```

### Stub 函數

```bash
claude "為這個測試生成適當的 stubs"
```

### Test Fixtures

```bash
claude "建立測試 fixtures 用於：
- 測試用戶資料
- 測試訂單資料
- 測試產品資料"
```

## 測試配置

### 設定測試環境

```bash
claude "建立 Jest 配置檔，包含：
- 測試覆蓋率設定
- Mock 設定
- 測試環境設定"
```

### 測試輔助函數

```bash
claude "建立測試輔助函數庫，包含：
- 資料庫設置/清理
- 通用 assertions
- Mock 工廠函數"
```

## 最佳實踐

### 1. 遵循 AAA 模式

```javascript
// Arrange (準備)
const user = { name: 'Test', email: 'test@example.com' };

// Act (執行)
const result = validateUser(user);

// Assert (驗證)
expect(result.isValid).toBe(true);
```

### 2. 測試命名規範

```bash
claude "使用清楚的測試命名：
- describe: 描述測試的對象
- it: 描述預期行為
- 使用 should 開頭"
```

### 3. 一個測試只驗證一件事

```bash
# 好的測試
it('should return true for valid email', () => {
  expect(isValidEmail('test@example.com')).toBe(true);
});

# 避免在單一測試中驗證多件事
```

### 4. 避免測試實作細節

```bash
claude "生成測試，只驗證公開 API 的行為，不測試內部實作"
```

### 5. 保持測試獨立

```bash
claude "確保每個測試都是獨立的，不依賴其他測試的執行順序"
```

## 測試覆蓋率目標

| 代碼類型 | 建議覆蓋率 |
|---------|-----------|
| 核心業務邏輯 | 90-100% |
| API 端點 | 80-90% |
| 工具函數 | 80-90% |
| UI 元件 | 60-80% |
| 配置檔案 | 不需要 |

## 持續整合測試

### GitHub Actions

```yaml
# .github/workflows/test.yml
name: Tests
on: [push, pull_request]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Run Tests
        run: npm test -- --coverage
      - name: Upload Coverage
        uses: codecov/codecov-action@v2
```

### 自動生成測試報告

```bash
claude "建立腳本，自動運行測試並生成 HTML 報告"
```

## 常見問題

### Q: 需要為所有代碼寫測試嗎？
A: 優先為核心業務邏輯和經常變動的部分寫測試。配置檔和簡單的 getter/setter 可以跳過。

### Q: 測試覆蓋率應該達到多少？
A: 80% 是一個好的目標，但不要盲目追求 100%。重點是測試關鍵功能。

### Q: 如何測試私有方法？
A: 通常不直接測試私有方法，而是通過測試公開 API 間接涵蓋。如果私有方法很複雜，可能需要重構。

### Q: 測試速度太慢怎麼辦？
A: 使用 Mock 避免真實的資料庫/網路操作，並行運行測試，只運行相關的測試。

## 小技巧

1. **先寫失敗的測試**：確保測試真的在檢查功能
2. **使用描述性的變數名**：讓測試像文檔一樣易讀
3. **定期運行測試**：建議每次 commit 前都運行
4. **保持測試簡潔**：複雜的測試往往是代碼需要重構的信號

## 延伸閱讀

- [4.3 代碼重構](./4.3-code-refactoring.md) - 重構時的測試策略
- [6.3 生成測試](../chapter6/6.3-generate-tests.md) - 實戰練習
- 《單元測試的藝術》

---

⏳ 內容持續補充中

## 導航

- **上一節**: [4.3 代碼重構](./4.3-code-refactoring.md)
- **下一節**: [4.5 文檔生成](./4.5-documentation.md)
- **返回章節目錄**: [第四章目錄](./README.md)
- **返回首頁**: [教材首頁](../../README.md)
