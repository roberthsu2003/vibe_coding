# 5.5 測試要求整合

## 💡 概念說明

將測試要求整合到 System Prompt 中,確保 AI 產生的程式碼不僅功能正確,還包含完整的測試覆蓋。

---

## 🎯 為什麼整合測試要求

### 好處
- ✅ AI 自動產生測試程式碼
- ✅ 提升程式碼品質
- ✅ 減少手動撰寫測試時間
- ✅ 確保測試覆蓋率
- ✅ 測試與實作同步

### 整合層級
1. **專案層級** - 通用測試規範
2. **模組層級** - 特定模組測試要求
3. **功能層級** - 特定功能測試策略

---

## 📋 測試規範設定

### 基本測試要求

**在 `CLAUDE.md` 中加入:**

```markdown
## 🧪 測試要求

### 測試框架
- **前端**: Jest + React Testing Library
- **後端**: Jest + Supertest
- **E2E**: Playwright

### 覆蓋率目標
- 單元測試: > 80%
- 整合測試: > 60%
- 關鍵路徑: 100%

### 測試原則
1. **每個功能都要有測試**
2. **測試要涵蓋成功和失敗情境**
3. **測試要清晰易讀**
4. **避免測試實作細節**

### 測試命名
使用「應該在 [情境] 時 [預期結果]」格式

### 測試組織
\`\`\`typescript
describe('功能或元件名稱', () => {
  describe('子功能', () => {
    it('應該在 [情境] 時 [預期結果]', () => {
      // AAA 模式: Arrange, Act, Assert
    });
  });
});
\`\`\`
```

---

## 🎨 具體範例

### 前端元件測試要求

```markdown
## React 元件測試規範

### 必須測試的項目
1. **渲染**: 元件是否正確渲染
2. **Props**: 不同 props 的行為
3. **互動**: 使用者互動(點擊、輸入等)
4. **狀態**: 狀態變化是否正確
5. **邊界情況**: null、undefined、空陣列等

### 範例要求
當 AI 產生元件時,同時產生對應的測試:

\`\`\`typescript
// UserCard.tsx
export const UserCard = ({ user, onDelete }: UserCardProps) => {
  // 元件實作
};

// UserCard.test.tsx - AI 應自動產生
describe('UserCard', () => {
  it('應該正確顯示使用者資訊', () => {
    const user = { id: '1', name: 'John', email: 'john@example.com' };
    render(<UserCard user={user} />);

    expect(screen.getByText('John')).toBeInTheDocument();
    expect(screen.getByText('john@example.com')).toBeInTheDocument();
  });

  it('應該在點擊刪除時呼叫 onDelete', async () => {
    const user = { id: '1', name: 'John', email: 'john@example.com' };
    const onDelete = jest.fn();

    render(<UserCard user={user} onDelete={onDelete} />);

    await userEvent.click(screen.getByRole('button', { name: /刪除/i }));

    expect(onDelete).toHaveBeenCalledWith('1');
  });

  it('應該在使用者為 null 時顯示載入狀態', () => {
    render(<UserCard user={null} />);

    expect(screen.getByText(/載入中/i)).toBeInTheDocument();
  });
});
\`\`\`

### 禁止事項
- ❌ 不測試實作細節(如內部 state 名稱)
- ❌ 不依賴特定的 HTML 結構
- ❌ 不使用 snapshot 測試(除非必要)
```

### 後端 API 測試要求

```markdown
## API 端點測試規範

### 必須測試的情境
1. **成功情況**: 正確的輸入和回應
2. **驗證錯誤**: 無效輸入的處理
3. **授權錯誤**: 未登入或權限不足
4. **資源不存在**: 404 錯誤
5. **伺服器錯誤**: 500 錯誤處理

### 範例要求
\`\`\`typescript
// userController.ts
export const getUser = async (req: Request, res: Response) => {
  // 實作
};

// userController.test.ts - AI 應自動產生
describe('GET /api/users/:id', () => {
  it('應該在提供有效 ID 時返回使用者', async () => {
    const response = await request(app)
      .get('/api/users/user123')
      .expect(200);

    expect(response.body).toMatchObject({
      success: true,
      data: {
        id: 'user123',
        name: expect.any(String),
        email: expect.any(String)
      }
    });
  });

  it('應該在使用者不存在時返回 404', async () => {
    const response = await request(app)
      .get('/api/users/nonexistent')
      .expect(404);

    expect(response.body).toMatchObject({
      success: false,
      error: {
        code: 'USER_NOT_FOUND',
        message: expect.any(String)
      }
    });
  });

  it('應該在未授權時返回 401', async () => {
    const response = await request(app)
      .get('/api/users/user123')
      .expect(401);  // 沒有 Authorization header
  });

  it('應該在資料庫錯誤時正確處理', async () => {
    // Mock 資料庫錯誤
    jest.spyOn(prisma.user, 'findUnique').mockRejectedValue(
      new Error('Database error')
    );

    const response = await request(app)
      .get('/api/users/user123')
      .expect(500);

    expect(response.body.success).toBe(false);
  });
});
\`\`\`
```

### 資料處理函數測試

```markdown
## 工具函數測試規範

### 必須測試
1. **基本功能**: 核心邏輯正確性
2. **邊界情況**: 極值、空值
3. **錯誤處理**: 異常輸入
4. **型別**: TypeScript 型別正確

### 範例
\`\`\`typescript
// formatDate.ts
export const formatDate = (date: Date, format: string): string => {
  // 實作
};

// formatDate.test.ts - AI 應自動產生
describe('formatDate', () => {
  it('應該正確格式化日期', () => {
    const date = new Date('2024-01-15');
    expect(formatDate(date, 'YYYY-MM-DD')).toBe('2024-01-15');
    expect(formatDate(date, 'DD/MM/YYYY')).toBe('15/01/2024');
  });

  it('應該處理無效日期', () => {
    const invalidDate = new Date('invalid');
    expect(() => formatDate(invalidDate, 'YYYY-MM-DD')).toThrow(
      'Invalid date'
    );
  });

  it('應該處理空格式字串', () => {
    const date = new Date('2024-01-15');
    expect(() => formatDate(date, '')).toThrow(
      'Format string is required'
    );
  });

  it('應該支援各種格式', () => {
    const date = new Date('2024-01-15T10:30:00');
    expect(formatDate(date, 'YYYY')).toBe('2024');
    expect(formatDate(date, 'HH:mm')).toBe('10:30');
  });
});
\`\`\`
```

---

## 🔧 特殊測試情境

### 1. 非同步操作測試

```markdown
## 非同步測試要求

### Promise/Async-Await
\`\`\`typescript
it('應該正確處理非同步操作', async () => {
  const result = await fetchUserData('user123');
  expect(result).toBeDefined();
});
\`\`\`

### 錯誤處理
\`\`\`typescript
it('應該在失敗時拋出錯誤', async () => {
  await expect(fetchUserData('invalid')).rejects.toThrow('User not found');
});
\`\`\`

### 超時處理
\`\`\`typescript
it('應該在超時時失敗', async () => {
  jest.setTimeout(1000);
  await expect(slowOperation()).rejects.toThrow('Timeout');
}, 1500);
\`\`\`
```

### 2. Mock 和 Stub

```markdown
## Mock 規範

### 何時使用 Mock
- 外部 API 呼叫
- 資料庫操作
- 檔案系統操作
- 時間相關功能

### Mock 範例
\`\`\`typescript
// Mock 外部服務
jest.mock('@/services/emailService', () => ({
  sendEmail: jest.fn().mockResolvedValue({ success: true })
}));

it('應該發送歡迎郵件', async () => {
  await registerUser({ email: 'user@example.com', name: 'User' });

  expect(emailService.sendEmail).toHaveBeenCalledWith({
    to: 'user@example.com',
    template: 'welcome',
    data: { name: 'User' }
  });
});
\`\`\`

### Mock 清理
\`\`\`typescript
afterEach(() => {
  jest.clearAllMocks();
});
\`\`\`
```

### 3. 整合測試

```markdown
## 整合測試要求

### 資料庫測試
- 使用測試資料庫
- 每個測試前清空資料
- 使用 transactions rollback

\`\`\`typescript
describe('User Service Integration', () => {
  beforeEach(async () => {
    await prisma.user.deleteMany();
  });

  it('應該建立使用者並儲存到資料庫', async () => {
    const user = await userService.createUser({
      email: 'test@example.com',
      name: 'Test User'
    });

    const saved = await prisma.user.findUnique({
      where: { id: user.id }
    });

    expect(saved).toBeDefined();
    expect(saved.email).toBe('test@example.com');
  });
});
\`\`\`
```

---

## 📊 測試覆蓋率設定

### Jest 配置

```markdown
## Jest 設定檔要求

AI 產生的測試配置應包含:

\`\`\`javascript
// jest.config.js
module.exports = {
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80
    },
    // 關鍵模組要求 100%
    './src/payment/': {
      branches: 100,
      functions: 100,
      lines: 100,
      statements: 100
    }
  },
  collectCoverageFrom: [
    'src/**/*.{ts,tsx}',
    '!src/**/*.d.ts',
    '!src/**/*.test.{ts,tsx}',
    '!src/types/'
  ]
};
\`\`\`
```

---

## ✅ 測試檢查清單

### AI 產生程式碼時必須包含

- [ ] 單元測試檔案
- [ ] 測試涵蓋主要功能
- [ ] 測試成功和失敗情境
- [ ] 測試邊界情況
- [ ] Mock 外部依賴
- [ ] 清晰的測試描述
- [ ] AAA 模式組織(Arrange, Act, Assert)

---

## 🔑 關鍵要點

> **將測試要求整合到 System Prompt,讓 AI 產生的程式碼天生具備高品質測試。**

記住:
- 🧪 明確測試框架和工具
- 📊 設定覆蓋率目標
- 📝 提供測試範例
- ✅ 列出必測項目
- 🚫 說明測試禁止事項

---

## 📚 延伸閱讀

- [4.1 React + TypeScript 範例](../chapter4/4.1-react-typescript.md)
- [4.2 Node.js 後端範例](../chapter4/4.2-nodejs-backend.md)
- [附錄 B: 常見問題](../appendix/B-faq.md)

## 導航

- **上一節**: [5.4 多語言專案處理](./5.4-multilingual-projects.md)
- **下一章**: [附錄](../appendix/README.md)
- **返回**: [教材首頁](../../README.md)
