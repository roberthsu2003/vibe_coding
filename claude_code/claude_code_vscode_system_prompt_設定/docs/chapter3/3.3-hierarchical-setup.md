# 3.3 階層化設定實戰

## 🎯 實戰目標

本節將手把手帶您建立一個階層化的 System Prompt 設定,實際應用在全端專案中。

---

## 📋 專案範例: 電商平台

我們將建立一個電商平台的完整設定結構:

```
ecommerce-platform/
├── CLAUDE.md                    # 1. 專案根目錄
├── frontend/
│   ├── CLAUDE.md               # 2. 前端模組
│   ├── customer/               # 客戶端
│   └── admin/
│       └── CLAUDE.md           # 3. Admin 模組
├── backend/
│   ├── CLAUDE.md               # 4. 後端模組
│   └── payment/
│       └── CLAUDE.md           # 5. 支付服務
└── tests/
    └── CLAUDE.md               # 6. 測試模組
```

---

## 🔨 步驟 1: 建立專案根目錄設定

### 1.1 建立檔案

```bash
# 切換到專案根目錄
cd ecommerce-platform

# 建立 CLAUDE.md
touch CLAUDE.md
```

### 1.2 撰寫內容

**`CLAUDE.md`:**

```markdown
# 電商平台專案

## 🎯 專案概觀
現代化的全端電商平台,提供商品管理、訂單處理、支付整合等功能。

## ⚙️ 技術棧
- **程式語言**: TypeScript 5.0+
- **前端**: React 18
- **後端**: Node.js + Express
- **資料庫**: PostgreSQL + Prisma
- **驗證**: JWT

## 📏 通用編碼規範

### TypeScript
- 啟用嚴格模式 (`strict: true`)
- 避免使用 `any`,優先使用 `unknown`
- 所有函數需要明確的回傳型別

### 命名慣例
- 變數/函數: camelCase
- 元件/類別: PascalCase
- 常數: UPPER_SNAKE_CASE
- 檔案: kebab-case

### 程式碼風格
- 使用 2 空格縮排
- 單引號字串
- 每行最多 100 字元
- 使用 Prettier 格式化

### 註解與文件
- 所有 public 函數需要 JSDoc
- 複雜邏輯需要內聯註解
- 註解使用繁體中文

## 🚫 通用禁止事項
- ❌ 不使用 `any` 型別
- ❌ 不直接修改 state (immutable)
- ❌ 不在程式碼中硬編碼敏感資訊
- ❌ 避免深層巢狀 (不超過 3 層)

## 🔗 API 互動規範
所有 API 呼叫必須:
- 統一錯誤處理
- 包含請求超時設定
- 記錄關鍵操作
- 處理網路失敗情況

## 🧪 測試要求
- 單元測試覆蓋率 > 80%
- 使用 Jest + Testing Library
- 測試檔案與源檔案同目錄

## 📝 Git 提交規範
使用 Conventional Commits:
- feat: 新功能
- fix: 錯誤修復
- docs: 文件更新
- refactor: 程式碼重構
- test: 測試相關
```

---

## 🔨 步驟 2: 建立前端模組設定

### 2.1 建立檔案

```bash
# 進入 frontend 目錄
cd frontend

# 建立 CLAUDE.md
touch CLAUDE.md
```

### 2.2 撰寫內容

**`frontend/CLAUDE.md`:**

```markdown
# 前端模組設定

> 本模組**繼承專案根目錄的所有規範**,並額外遵循以下前端特定規則

## ⚙️ 前端技術棧
- **框架**: React 18 (Function Components)
- **狀態管理**: Zustand
- **樣式**: Tailwind CSS 3.x
- **路由**: React Router v6
- **表單**: React Hook Form + Zod
- **HTTP**: Axios

## 📏 React 特定規範

### 元件開發
- 僅使用 Function Components
- 使用 Hooks 管理狀態和副作用
- Props 必須定義 TypeScript interface
- 元件保持單一職責

### Hooks 使用
- 自訂 Hooks 以 `use` 開頭
- 遵循 Hooks 規則 (不在條件式中呼叫)
- 複雜邏輯封裝成 Hooks

### 樣式規範
- 使用 Tailwind CSS utility classes
- 避免 inline styles (除非動態樣式)
- 共用樣式提取為 Tailwind 元件

## 🏗️ 檔案結構
\`\`\`
frontend/
├── components/     # 可重用元件
│   ├── common/    # 通用元件
│   └── features/  # 功能元件
├── pages/         # 頁面元件
├── hooks/         # 自訂 Hooks
├── stores/        # Zustand stores
├── services/      # API 服務
└── utils/         # 工具函數
\`\`\`

## 🚫 前端禁止事項
- ❌ 不使用 Class Components
- ❌ 不使用 CSS-in-JS (如 styled-components)
- ❌ 不在元件內直接呼叫 API
  ✅ 使用 services 層

- ❌ 不使用 export default
  ✅ 使用具名匯出

## 🔗 API 呼叫範例
\`\`\`typescript
// ✅ 正確: 使用 service 層
import { userService } from '@/services/userService';
const user = await userService.getUser(userId);

// ❌ 錯誤: 直接在元件呼叫
const user = await axios.get('/api/users/' + userId);
\`\`\`

## 🎨 元件範例
\`\`\`typescript
interface UserCardProps {
  userId: string;
  onUpdate?: (user: User) => void;
}

/**
 * 使用者卡片元件
 */
export const UserCard = ({ userId, onUpdate }: UserCardProps) => {
  // 實作...
};
\`\`\`
```

---

## 🔨 步驟 3: 建立 Admin 模組設定

### 3.1 建立檔案

```bash
# 在 frontend/admin 目錄
mkdir -p frontend/admin
cd frontend/admin

# 建立 CLAUDE.md
touch CLAUDE.md
```

### 3.2 撰寫內容

**`frontend/admin/CLAUDE.md`:**

```markdown
# Admin 管理介面設定

> 本模組**繼承前端所有規範**,並加強安全性要求

## 🔒 安全性要求 (Admin 專屬)

### 權限檢查
- 每個操作前檢查 admin 權限
- 敏感操作需要二次確認
- Token 過期自動登出

\`\`\`typescript
// ✅ 正確: 包含權限檢查
const deleteUser = async (userId: string) => {
  if (!hasAdminPermission('user:delete')) {
    throw new UnauthorizedError('無刪除權限');
  }

  const confirmed = await confirmDialog('確定刪除此使用者?');
  if (!confirmed) return;

  await userService.delete(userId);
  logAdminAction('delete_user', { userId });
};

// ❌ 錯誤: 缺少權限檢查
const deleteUser = async (userId: string) => {
  await userService.delete(userId);
};
\`\`\`

### 稽核日誌
所有 admin 操作必須記錄:
- 操作者 ID
- 操作類型
- 操作時間
- 受影響的資料
- IP 位址

### 資料顯示
- 避免完整顯示敏感資料
- 使用資料遮罩 (如: 部分隱藏信用卡號)
- 限制批次操作數量

## 🚫 Admin 模組禁止事項
- ❌ 不允許批次刪除超過 10 筆
  ✅ 需逐筆確認

- ❌ 不允許繞過權限檢查
  ✅ 所有操作都需驗證

- ❌ 不儲存明文密碼
  ✅ 使用雜湊值

## 📊 UI/UX 要求
- 危險操作使用紅色警告
- 重要操作需要確認對話框
- 操作結果明確回饋
```

---

## 🔨 步驟 4: 建立後端模組設定

### 4.1 建立檔案

```bash
# 在 backend 目錄
cd ../../backend

# 建立 CLAUDE.md
touch CLAUDE.md
```

### 4.2 撰寫內容

**`backend/CLAUDE.md`:**

```markdown
# 後端 API 模組設定

> 本模組**繼承專案通用規範**,並遵循後端特定規則

## ⚙️ 後端技術棧
- **框架**: Express.js
- **ORM**: Prisma
- **驗證**: JWT + Passport
- **驗證**: Zod schema
- **日誌**: Winston

## 📏 API 設計規範

### RESTful API
- 使用正確的 HTTP 方法 (GET/POST/PUT/DELETE)
- 回應統一的 JSON 格式
- 使用適當的狀態碼

### 錯誤處理
\`\`\`typescript
// ✅ 統一錯誤處理中介軟體
app.use((err, req, res, next) => {
  logger.error(err);
  res.status(err.statusCode || 500).json({
    success: false,
    message: err.message,
    ...(process.env.NODE_ENV === 'development' && { stack: err.stack })
  });
});
\`\`\`

### 輸入驗證
- 所有輸入使用 Zod 驗證
- 驗證失敗返回 400 和詳細錯誤

## 🏗️ 後端結構
\`\`\`
backend/
├── controllers/    # 控制器
├── services/       # 業務邏輯
├── models/         # 資料模型 (Prisma)
├── middlewares/    # 中介軟體
├── routes/         # 路由定義
├── utils/          # 工具函數
└── config/         # 配置檔
\`\`\`

## 🔐 安全性
- 所有端點需要 rate limiting
- 敏感操作需要驗證
- SQL 注入防護 (使用 Prisma)
- XSS 防護
- CORS 正確配置

## 🗄️ 資料庫操作
\`\`\`typescript
// ✅ 正確: 使用 Prisma,有錯誤處理
const getUser = async (id: string) => {
  try {
    const user = await prisma.user.findUnique({
      where: { id },
      select: { id: true, name: true, email: true }
    });
    if (!user) {
      throw new NotFoundError('使用者不存在');
    }
    return user;
  } catch (error) {
    logger.error('Get user failed', { id, error });
    throw error;
  }
};

// ❌ 錯誤: 缺少錯誤處理
const getUser = async (id: string) => {
  return prisma.user.findUnique({ where: { id } });
};
\`\`\`

## 📝 日誌要求
- 記錄所有 API 請求
- 記錄錯誤和異常
- 記錄資料庫操作
- 記錄安全相關事件
```

---

## 🔨 步驟 5: 建立支付服務設定

### 5.1 建立檔案

```bash
# 在 backend/payment 目錄
mkdir -p backend/payment
cd backend/payment

# 建立 CLAUDE.md
touch CLAUDE.md
```

### 5.2 撰寫內容

**`backend/payment/CLAUDE.md`:**

```markdown
# Payment 支付服務設定

> 本服務處理金流,**最高安全等級**,額外規範如下:

## 💰 金額處理
- ❗ 所有金額使用 Decimal 型別 (不用 number)
- 四捨五入統一規則
- 貨幣單位明確標示

\`\`\`typescript
import { Decimal } from 'decimal.js';

// ✅ 正確: 使用 Decimal
const totalAmount = new Decimal(price)
  .mul(quantity)
  .mul(new Decimal(1).plus(taxRate));

// ❌ 錯誤: 使用 float
const totalAmount = price * quantity * (1 + taxRate);
\`\`\`

## 🔐 安全要求
- 信用卡資訊不儲存明文
- 使用 PCI DSS 合規的第三方
- 實作 3D Secure 驗證
- 所有通訊使用 HTTPS
- 敏感日誌資料遮罩

## 🔄 交易處理
### Idempotency (冪等性)
- 使用 idempotency key 防止重複
- 相同請求返回相同結果
- 保存請求歷史

### 錯誤處理
\`\`\`typescript
const processPayment = async (paymentData: PaymentInput) => {
  const transaction = await prisma.$transaction(async (tx) => {
    try {
      // 1. 驗證金額
      validateAmount(paymentData.amount);

      // 2. 檢查冪等性
      const existing = await checkIdempotency(paymentData.idempotencyKey);
      if (existing) return existing;

      // 3. 呼叫第三方支付
      const result = await paymentGateway.charge(paymentData);

      // 4. 記錄交易
      await logTransaction(result);

      // 5. 更新訂單狀態
      await tx.order.update({
        where: { id: paymentData.orderId },
        data: { status: 'PAID', paidAt: new Date() }
      });

      return result;
    } catch (error) {
      // 記錄失敗
      await logPaymentFailure(paymentData, error);

      // 告警
      await alertService.criticalError({
        service: 'payment',
        error: error.message,
        data: sanitizePaymentData(paymentData)
      });

      throw error;
    }
  });

  return transaction;
};
\`\`\`

## 📊 監控與告警
- 交易成功率監控
- 異常金額告警
- 失敗率超過閾值告警
- 回應時間監控

## 🧪 測試要求
- 100% 覆蓋率 (支付邏輯)
- 測試各種失敗情況
- 測試重複請求
- 測試交易回滾
- 測試金額計算精確度

## 🚫 絕對禁止
- ❌ 絕對不儲存完整信用卡號
- ❌ 絕對不記錄 CVV
- ❌ 絕對不在錯誤訊息洩露敏感資訊
- ❌ 不允許跳過任何驗證步驟
```

---

## 🔨 步驟 6: 建立測試模組設定

### 6.1 建立檔案

```bash
# 在專案根目錄的 tests 資料夾
cd ../../tests

# 建立 CLAUDE.md
touch CLAUDE.md
```

### 6.2 撰寫內容

**`tests/CLAUDE.md`:**

```markdown
# 測試模組設定

> 測試程式碼有專屬的規範和風格

## 🧪 測試框架
- Jest + Testing Library
- Supertest (API 測試)
- MSW (API Mocking)

## 📋 測試組織
\`\`\`typescript
describe('UserService', () => {
  describe('getUser', () => {
    it('應該在提供有效 ID 時返回使用者', async () => {
      // Arrange
      const userId = 'user123';

      // Act
      const user = await userService.getUser(userId);

      // Assert
      expect(user).toBeDefined();
      expect(user.id).toBe(userId);
    });

    it('應該在使用者不存在時拋出錯誤', async () => {
      // Arrange
      const userId = 'nonexistent';

      // Act & Assert
      await expect(
        userService.getUser(userId)
      ).rejects.toThrow('使用者不存在');
    });
  });
});
\`\`\`

## 📏 測試規範
- 測試名稱: 「應該在 [情境] 時 [預期結果]」
- AAA 模式: Arrange, Act, Assert
- 一個測試一個斷言 (SPOT)
- 測試資料使用 factories

## 🎭 Mock 規範
- 最小化 mock
- Mock 放在 `__mocks__` 目錄
- 測試後清除 mock
- 使用 MSW mock API

## 📊 覆蓋率要求
- 單元測試: > 80%
- 整合測試: > 60%
- 關鍵路徑: 100%

## ✅ 測試中允許的例外
- 可以使用 `any` 在 mock 型別
- 可以使用較長的函數 (測試情境多)
- 測試資料可以硬編碼
```

---

## ✅ 步驟 7: 驗證設定

### 7.1 檢查檔案結構

```bash
# 在專案根目錄執行
find . -name "CLAUDE.md" -type f
```

預期輸出:
```
./CLAUDE.md
./frontend/CLAUDE.md
./frontend/admin/CLAUDE.md
./backend/CLAUDE.md
./backend/payment/CLAUDE.md
./tests/CLAUDE.md
```

### 7.2 測試階層載入

在不同目錄的檔案中測試 Claude Code:

**測試 1: 在 `frontend/admin/AdminPanel.tsx`**
- 應該遵循專案通用規範
- 應該遵循前端規範
- 應該遵循 Admin 安全規範

**測試 2: 在 `backend/payment/paymentService.ts`**
- 應該遵循專案通用規範
- 應該遵循後端規範
- 應該遵循支付服務的嚴格規範

---

## 📊 設定層級視覺化

```
專案根目錄 CLAUDE.md (基礎規範)
    ↓ 繼承 + 擴展
    ├─→ frontend/CLAUDE.md (前端規範)
    │       ↓ 繼承 + 擴展
    │       └─→ frontend/admin/CLAUDE.md (Admin 強化)
    │
    ├─→ backend/CLAUDE.md (後端規範)
    │       ↓ 繼承 + 擴展
    │       └─→ backend/payment/CLAUDE.md (支付強化)
    │
    └─→ tests/CLAUDE.md (測試規範)
```

---

## 💡 最佳實踐回顧

### ✅ 做到了
1. **清晰的繼承關係** - 每個子設定明確說明繼承
2. **避免重複** - 只寫差異部分
3. **具體範例** - 提供正確/錯誤對比
4. **實用性** - 針對真實需求設定

### ⚠️ 注意事項
1. **不要過度細分** - 只在真正需要時建立子設定
2. **定期審查** - 移除過時規則
3. **團隊共識** - 確保團隊理解階層結構
4. **文件記錄** - 在 README 說明結構原因

---

## 🎯 檢查清單

完成階層化設定後,確認:

- [ ] 根目錄 `CLAUDE.md` 包含通用規範
- [ ] 各模組 `CLAUDE.md` 只包含差異部分
- [ ] 每個子設定明確說明繼承關係
- [ ] 提供具體的程式碼範例
- [ ] 測試不同層級的設定生效
- [ ] 加入 Git 版本控制
- [ ] 團隊成員了解結構

---

## 📚 延伸學習

- [第四章: 實用範例集](../chapter4/README.md) - 更多完整範例
- [第五章: 進階技巧](../chapter5/README.md) - 動態調整和團隊協作

## 導航

- **上一節**: [3.2 實際應用場景](./3.2-use-cases.md)
- **下一章**: [第四章: 實用範例集](../chapter4/README.md)
- **返回**: [教材首頁](../../README.md)
